# dashboard
import streamlit as st
from streamlit_elements import dashboard
from streamlit_elements import nivo, elements, mui, media

# data 
import pandas as pd
import numpy as np
import re
import time
import datetime
import calendar
import seaborn as sns
import matplotlib.pyplot as plt
import plotly.express as px
from scipy.stats import shapiro, levene,ttest_ind

from tqdm import tqdm
from stqdm import stqdm

from lifetimes.plotting import *
from lifetimes.utils import *
from lifetimes.plotting import *
from lifetimes.utils import *
from lifetimes import BetaGeoFitter
from lifetimes.fitters.gamma_gamma_fitter import GammaGammaFitter

from hyperopt import hp, fmin, tpe, rand, SparkTrials, STATUS_OK, space_eval, Trials




# scraping
from webdriver_manager.chrome import ChromeDriverManager
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.by import By
from selenium.webdriver.common.alert import Alert
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options

# google cloud platform
import io
from googleapiclient.discovery import build
from google.cloud import storage, bigquery
from google.oauth2 import service_account

# ÏùºÎ∂Ä css
with open( "webtoon.css" ) as css:
    st.markdown( f'<style>{css.read()}</style>' , unsafe_allow_html= True)
pd.set_option('mode.chained_assignment',  None)

# Îç∞Ïù¥ÌÑ∞ ÏàòÏßë ÎÇ†Ïßú
now = datetime.datetime.now()
now_time = now.strftime("%Y-%m-%d")
st.caption(' Ìï¥Îãπ ÎåÄÏãúÎ≥¥ÎìúÎäî 220606 ~ 240303 Í∏∞Í∞ÑÎèôÏïàÏùò Îç∞Ïù¥ÌÑ∞ Í∏∞Ï§ÄÏúºÎ°ú ÎßåÎì§Ïñ¥Ï°åÏäµÎãàÎã§. üòÄ') #.strftime('%Y-%m-%d %H:%M'))



# ---------------------------------------------------------------- GOOGLE Cloud Storage Ïóê Îç∞Ïù¥ÌÑ∞ Ïó∞Í≤∞ ----------------------------------------------------------- #

# ------------- Create API client ----------------------------------- #

credentials = service_account.Credentials.from_service_account_info(
    st.secrets["gcp_service_account"]
)
client = bigquery.Client(credentials=credentials)


main_bucket = 'naver_webtoon'
data_folder = ['baeksoon/user_id/', 'baeksoon/main_data/']



def load_data(data_folder):
    client = storage.Client(credentials=credentials)
    bucket = client.bucket(main_bucket)
    blobs = bucket.list_blobs()

    # Ìè¥Îçî ÏïàÏóê ÏûàÎäî CSV ÌååÏùºÎßå ÌïÑÌÑ∞ÎßÅÌï©ÎãàÎã§.

    comment_data =  [blob for blob in blobs if blob.name.startswith(data_folder) and blob.name.endswith('.csv')]

    # CSV ÌååÏùºÏùÑ DataFramesÎ°ú Î≥ÄÌôòÌï©ÎãàÎã§.
    dfs = []
    for blob in comment_data:
        csv_data = blob.download_as_string()
        df = pd.read_csv(io.StringIO(csv_data.decode('utf-8')))
        dfs.append(df)

    # Î™®Îì† DataFramesÎ•º Î≥ëÌï©Ìï©ÎãàÎã§.
    data = pd.concat(dfs)
    return data






# Îç∞Ïù¥ÌÑ∞ Î∂àÎü¨Ïò§Í∏∞ side_bar
with st.sidebar:
    # st.image('https://image-comic.pstatic.net/webtoon/811721/thumbnail/thumbnail_IMAG21_9a2a959a-666b-4156-8e4f-db64dfe319c6.jpg',width=200)
    with st.form(key ='searchform'):
        col1,col2= st.columns([2,2]) 
        with col1:         
            st.subheader("webtoon dataset")
        
        with col2:    
            submit_search = st.form_submit_button('data')
            scraping = st.form_submit_button('comment')

# Îç∞Ïù¥ÌÑ∞ Î∂àÎü¨Ïò§Í∏∞
if submit_search:
    comment_data = load_data(data_folder[0])
    main_data = load_data(data_folder[1])

    st.session_state.comment_data = comment_data
    st.session_state.main_data = main_data




if hasattr(st.session_state, 'main_data'):
    main_data = st.session_state.main_data
    main_data['chapter'] = main_data['episode'].apply(lambda x: re.search(r'\b(\d+)\D', x).group(1) if re.search(r'\b(\d+)\D', x) else None).astype(int)

    # ÎÇ†Ïßú Ïª¨ÎüºÏùÑ datetime ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò 
    main_data['upload_at'] = pd.to_datetime(main_data['upload_at'], errors='coerce')

    # Î≥ÄÌôòÎêú ÎÇ†ÏßúÎ•º ÏõêÌïòÎäî ÌòïÏãùÏúºÎ°ú Ï∂úÎ†•
    main_data['upload_at'] = main_data['upload_at'].dt.strftime('%Y-%m-%d')


    # main_data['upload_at'] = pd.to_datetime(main_data['upload_at'],format='%Y-%m-%d')
    # main_data['year'] = main_data['upload_at'].dt.year.astype(str)
    # main_data['month'] = main_data['upload_at'].dt.month.astype(str)


    # @st.cache_resource
    # def data_diff (data):
    #     # data = pd.concat(dfs) if dfs else ''
    #     data = data.sort_values(by=['upload_at', 'down_at'])

    #     data['like_count'] = data['like_count'].str.replace(',', '').astype(int)
    #     data['comment_count'] = data['comment_count'].str.replace(',', '').astype(int)

    #     data['user_response'] = data['like_count'] + data['comment_count'] + data['score_count']



    #     data['down_at'] = pd.to_datetime(data['down_at']).dt.strftime('%Y-%m-%d')
    #     data['down_at'] = pd.to_datetime(data['down_at'], format='%Y-%m-%d')
    #     # data = data[data['down_at'] > '2023-10-01'] ################################################ 

    #     # year Í≥º month Î•º Íµ¨Î∂ÑÌï¥Ï£ºÏûê.
    #     # data['year'] = data['upload_at'].dt.year.astype(str)
    #     # data['month'] = data['upload_at'].dt.month.astype(str)

    #     # Ï†ÑÏùº ÎåÄÎπÑ Ï°∞ÌöåÏàòÎ∞è Ï¢ãÏïÑÏöî Ïª¨Îüº
    #     data['prev_user_response'] = data.groupby(['chapter','upload_at'])['user_response'].shift()
    
    #     # data.loc[(data['down_at'] - data['upload_at'] ).dt.days == 1, 'user_response'] = 0

    #     data['response_diff'] = data['user_response'] - data['prev_user_response']

    #     # data['down_at'] = pd.to_datetime(data['down_at']).dt.strftime('%Y-%m-%d')    

    
    #     return data
    
    # data = data_diff(main_data)
    # st.write(data)


    # # ÏùºÎ≥Ñ ÎèÖÏûêÎì§Ïùò Ï∞∏Ïó¨ÎèÑ (Ï¢ãÏïÑÏöî+ÎåìÍ∏Ä+ÌèâÏ†ê Ï∞∏Í∞ÄÎ•º Ìï©Ïπú Í∞í)
    # response_df = data.groupby(['down_at']).agg(
    #    total_response = pd.NamedAgg(column='response_diff', aggfunc='sum')
    # ).reset_index()


    # nivo_data_response = []
    # for index, row in response_df.iterrows():
    #     nivo_data_response.append({'x': row['down_at'], 'y': row['total_response']})

    # nivo_data_response = [{
    #     "id": "response",
    #     "data": nivo_data_response
    # }]
    # today_response = response_df['total_response'].iloc[-1]
    # with st.container():       
    #         with elements("response_by_day"):
    #             layout = [
    #                 dashboard.Item("item_1", 0, 0, 4, 2),

    #             ]
    #             with dashboard.Grid(layout):

    #                 mui.Box( # subscribe
    #                     children = [
    #                         mui.Typography(
    #                             "Today Count",
    #                             variant="body2",
    #                             sx={"fontFamily":"Pretendard Variable",
    #                                 "font-size": "18px",
    #                                 "pt":2} ,
    #                         ),

    #                         mui.Typography(
    #                             f"{today_response}",
    #                             variant="body2",
    #                             sx={
    #                                 "font-size": "32px",
    #                                 "fontWeight":"bold",
    #                                 "padding-top": 0
    #                                 } ,
                                
    #                         ),
                            
    #                         mui.Divider(),

    #                         mui.Typography(
    #                             'ÏùºÎ≥Ñ ÎèÖÏûê Î∞òÏùë(Ï¢ãÏïÑÏöî+ÎåìÍ∏Ä+ÌèâÏ†êÏ∞∏Ïó¨)',
    #                                 variant="body2",
    #                                 color="text.secondary",
    #                                 sx={'pt':1,"font-size": "10px"}
    #                         ),

    #                         nivo.Line(
    #                             data= nivo_data_response,
    #                             margin={'top': 0, 'right': 30, 'bottom': 150, 'left': 60},
    #                             # xScale={'type': 'point',
    #                             #         },

    #                             curve="monotoneX",
    #                             axisTop=None,
    #                             axisRight=None,
    #                             axisBottom={
    #                                 'format': '%m-%d',  # '%Y-%m-%d'
    #                                 'legendOffset': -12,
    #                                 'tickValues': 'every 3 days'
    #                             },
    #                             xFormat="time:%Y-%m-%d",
    #                             xScale={
    #                                 'format': '%Y-%m-%d',
    #                                 'precision': 'day',
    #                                 'type': 'time',
    #                                 # 'useUTC': False
    #                             },
    #                             colors= {'scheme': 'accent'},

    #                             enableGridX = False,
    #                             enableGridY = False,
    #                             enableArea = True,
    #                             areaOpacity = 0.2,
    #                             # enablePointLabel=True,
    #                             # pointLabel='y',
    #                             lineWidth=2,
    #                             pointSize=3,
    #                             pointColor='white',
    #                             pointBorderWidth=0.5,
    #                             pointBorderColor={'from': 'serieColor'},
    #                             pointLabelYOffset=-12,
    #                             useMesh=True,
    #                             legends=[
    #                                         {
    #                                         'anchor': 'top-left',
    #                                         'direction': 'column',
    #                                         'justify': False,
    #                                         # 'translateX': -30,
    #                                         # 'translateY': -200,
    #                                         'itemsSpacing': 0,
    #                                         'itemDirection': 'left-to-right',
    #                                         'itemWidth': 80,
    #                                         'itemHeight': 15,
    #                                         'itemOpacity': 0.75,
    #                                         'symbolSize': 12,
    #                                         'symbolShape': 'circle',
    #                                         'symbolBorderColor': 'rgba(0, 0, 0, .5)',
    #                                         'effects': [
    #                                                 {
    #                                                 'on': 'hover',
    #                                                 'style': {
    #                                                     'itemBackground': 'rgba(0, 0, 0, .03)',
    #                                                     'itemOpacity': 1
    #                                                     }
    #                                                 }
    #                                             ]
    #                                         }
    #                                     ],                            
    #                             theme={
    #                                     # "background-color": "rgba(158, 60, 74, 0.2)",
    #                                     "textColor": "black",
    #                                     "tooltip": {
    #                                         "container": {
    #                                             "background": "#3a3c4a",
    #                                             "color": "white",
    #                                         }
    #                                     }
    #                                 },                                           
    #                             animate= False)
    #                             ]                                
    #                         ,key="item_1",sx={"text-align":"center"})





if hasattr(st.session_state, 'comment_data'):
    comment_data = st.session_state.comment_data


    # Ïù¥Î≤§Ìä∏Í∞Ä Ïã§ÌñâÎê† ÎïåÎßàÎã§ Ï†ÑÏ≤òÎ¶¨ ÏΩîÎìúÎì§Ïù¥ Ïã§ÌñâÎêòÏßÄ ÏïäÍ≤å cache_resource 
    @st.cache_resource
    def preprocessing (comment_data):
        # ÌÅ¥Î¶∞Î¥áÏóê ÏùòÌï¥ Ï†úÍ±∞Îêú ÎåìÍ∏Ä Ï†úÍ±∞
        comment_data = comment_data.dropna(axis=0)

        # NÏùºÏ†Ñ NÏãúÍ∞Ñ Ï†Ñ Í∞ôÏùÄ ÌòïÌÉúÏùò Í∞íÏù¥ ÏûàÎã§.
        # Ï†ïÍ∑ú ÌëúÌòÑÏãùÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ Ïà´ÏûêÎßå Ï∂îÏ∂úÌïòÍ≥† Îç∞Ïù¥ÌÑ∞ ÏàòÏßëÏùºÏù∏ '2024-03-08' Í∏∞Í∞ÑÍ≥º Î∫¥ÏïºÌïúÎã§.
        def extract_numbers(value):
            return int(re.sub(r"\D", "", value))  if isinstance(value, str) else None


        down_date = '2024-03-08'
        down_date = pd.to_datetime(down_date, format='%Y-%m-%d')
        
        # 'comment_date' Ïª¨ÎüºÏùò Í∞íÏóê '~Ïùº Ï†Ñ' ÌòïÏãùÏù∏ Í≤ΩÏö∞, Ïà´Ïûê Ï∂îÏ∂úÌïòÏó¨ 'col' Ïª¨ÎüºÏóê Ìï†Îãπ
        comment_data['comment_date'] = comment_data['comment_date'].apply(lambda x: extract_numbers(x) if 'Ïùº Ï†Ñ' in str(x) else x)
        comment_data['comment_date'] = comment_data['comment_date'].apply(lambda x: down_date - datetime.timedelta(days=x) if isinstance(x, int) else x)    

        # comment_date Ïó¥Ïùò Í∞íÏùÑ ÎÇ†Ïßú ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
        comment_data['comment_date'] = pd.to_datetime(comment_data['comment_date'], errors='coerce') # errors='coerce' Î•ºÌÜµÌï¥ '2ÏùºÏ†Ñ' Í∞ôÏùÄ Î¨∏ÏûêÏó¥ Í∞íÎì§ÏùÄ None Í∞íÏúºÎ°ú Î∞îÎÄåÍ≤å ÎêúÎã§.

        # Îç∞Ïù¥ÌÑ∞Îäî 2Ïõî ÎßàÏßÄÎßâÏ£º Î•º Í∏∞Ï§ÄÏúºÎ°ú ÏßëÍ≤å
        comment_data = comment_data.dropna(subset=['comment_date'])
        comment_data = comment_data[comment_data['comment_date'] <= '2024-03-03']

        comment_data['day_name'] = comment_data['comment_date'].dt.day_name()
        # ÏùºÏûêÎ≥Ñ ÌôúÏÑ± ÏÇ¨Ïö©Ïûê (DAU)
        dau = comment_data.groupby([comment_data['comment_date'].dt.date,'day_name'])['user_id'].nunique().reset_index() #  'day_name'
        # Ï£ºÍ∞ÑÎ≥Ñ ÌôúÏÑ± ÏÇ¨Ïö©Ïûê (WAU)
        wau = comment_data.groupby(comment_data['comment_date'].dt.to_period('W').dt.start_time.dt.date)['user_id'].nunique().reset_index()
        # ÏõîÍ∞ÑÎ≥Ñ ÌôúÏÑ± ÏÇ¨Ïö©Ïûê (MAU)
        mau = comment_data.groupby(comment_data['comment_date'].dt.to_period('M').dt.start_time.dt.date)['user_id'].nunique().reset_index()
        return  comment_data, dau, wau, mau
    
    comment_data, dau, wau, mau = preprocessing(comment_data)

    unique_user  = len(comment_data['user_id'].unique())  # ÎåìÍ∏ÄÏùÑ Îã¥Í∏¥ Ïú†ÎãàÌÅ¨Ìïú Ïú†Ï†Ä




    # ---------------------------------------------------------------- DAU, WAU, MAUÌôúÏÑ±Ìôî Ïú†Ï†Ä ÏßÄÌëú  ---------------------------------------------------------------- #

    with st.container():
        st.header(''' 
                Activation User  
                ''')
        st.caption(''' 
                   ÌôúÏÑ±Ìôî Ïú†Ï†ÄÏùò Í∏∞Ï§ÄÏùÄ 'ÎåìÍ∏Ä'ÏùÑ ÎÇ®Í∏¥ Ïú†Ï†ÄÎ°ú Ï†ïÌñàÏñ¥Ïöî. ÎåìÍ∏ÄÍ≥º Ï¢ãÏïÑÏöîÎäî ÏõπÌà∞ÏùÑ Î≥¥Í≥† ÎÇú Îí§, Ï¶â ÏÑúÎπÑÏä§Î•º Ïù¥Ïö©ÌñàÎã§Îäî Í∞ÄÏû• ÌôïÏã§Ìïú ÌùîÏ†ÅÏù¥ ÎùºÍ≥† ÏÉùÍ∞ÅÌñàÏäµÎãàÎã§.  
                   Í∑∏ Ï§ë ÏóêÌîºÏÜåÎìúÎ≥Ñ ÎÇ®Í≤®ÏßÑ ÎåìÍ∏ÄÏùò ÏïÑÏù¥ÎîîÎ•º Í∏∞Ï§ÄÏúºÎ°ú Í≥†Ïú† Ïú†Ï†ÄÏàòÎ•º ÏßëÍ≥Ñ ÌñàÏñ¥Ïöîü´°! ÏõπÌà∞ ÌéòÏù¥ÏßÄÏóêÏÑú Íµ¨Ìï† Ïàò ÏûàÎäî ÎåìÍ∏Ä Ï†ïÎ≥¥Î•º Ïù¥Ïö©ÌïòÏó¨ ÏùºÎ∂Ä ÌïÑÌÑ∞ÎßÅÎêú 'ÎãâÎÑ§ÏûÑ(id***)' Ïù¥ Í∞ôÎã§Î©¥ ÎèôÏùº Ïú†Ï†ÄÎ°ú ÌåêÎã®ÌñàÏäµÎãàÎã§. 
                     
                    ''')

        

        max_date = max(comment_data['comment_date'].dt.date) 
        min_date = min(comment_data['comment_date'].dt.date)


        # ÎÇ†Ïßú, activation ÏòµÏÖò columns
        col1,col2 = st.columns([1,4])
        with col1:
            d = st.date_input(
                "ÎÇ†Ïßú",
                (min_date, max_date),
                min_date, # ÏµúÏÜå ÎÇ†Ïßú
                max_date, # ÏµúÎåÄ ÎÇ†Ïßú
                format="YYYY.MM.DD",
            ) 
            if len(d) >= 2: 
                start_d = d[0]
                end_d = d[1]
            else:
                start_d = d[0]
                end_d = max_date

        with col2:

            indication = st.radio(
                "Ïú†Ï†Ä ÌôúÏÑ±Ìôî ÏßÄÌëú",
                ["DAU", "WAU", "MAU"],
                 horizontal=True, label_visibility="visible"
            )
        # ÏÑ†ÌÉùÎêú Í∞íÏùÑ Í∏∞Î∞òÏúºÎ°ú Ìï¥Îãπ Îç∞Ïù¥ÌÑ∞ÌîÑÎ†àÏûÑ Í∞ÄÏ†∏Ïò§Í∏∞
            if indication == "DAU":
                df = dau
            elif indication == "WAU":
                df = wau
            elif indication == "MAU":
                df = mau
            





        #     st.write(f''' ÌòÑÏû¨ {unique_user}Î™ÖÏùò ÎèÖÏûêÍ∞Ä ÏõπÌà∞ÏùÑ Î≥¥Í≥† ÎåìÍ∏ÄÏùÑ ÎÇ®Í≤ºÏñ¥Ïöî. 'Í∞úÍ∑∏' Ïû•Î•¥Ïùò Îã§Î•∏ ÏûëÌíàÏóê ÎπÑÌï¥ % ÎÜíÏùÄ ÏàòÏπòÏûÖÎãàÎã§!''')


        # ÌôúÏÑ±Ìôî ÏßÄÌëúÎ≥Ñ ÏãúÍ∞ÅÌôî Ìï®Ïàò
        def user_active_chart (df,title,color):
            title = indication
            date_mask = (df['comment_date'] >= start_d) & (df['comment_date'] <= end_d) # dateÎ°ú ÏßÄÏ†ïÎêú Í∞íÎì§Îßå 
            df = df.loc[date_mask]
            pivot = pd.pivot_table(df, values='user_id', index='comment_date')



            st.subheader(f'üìä {title}')
            st.line_chart(pivot, use_container_width=True,color=color)



        col1,col2 = st.columns([3,1])
        with col1:
            
            user_active_chart(df,'üìä Daily Active User','#75D060')
    
            st.markdown(''' 
                    > * Î¨¥ÏßÅÎ∞±ÏàòÍ≥ÑÎ∞±Ïàú ÏõπÌà∞Ïùò Í≤ΩÏö∞ ÏùºÏöîÏùº, ÏàòÏöîÏùºÏóê Ïó∞Ïû¨ÎêòÎäî ÏûëÌíàÏûÖÎãàÎã§. Ï†ïÌï¥ÏßÑ ÏöîÏùºÏóêÎßå Ïó∞Ïû¨ÎêòÎäî ÏõπÌà∞ ÌäπÏÑ±ÏÉÅ ÏöîÏùºÎ≥ÑÎ°ú ÌÅ∞ Î≥ÄÎèôÏÑ±Ïù¥ ÏûàÏóàÏäµÎãàÎã§.                                                                 
                    ''')
   

        # issue
        with col2:
            # st.subheader(' ‚úîÔ∏èIssue')

            st.markdown('''
                #### ÎèÖÏûêÎì§Ïùò Ïû¨Î∞©Î¨∏Ïù¥ ÎÜíÏùÑÍπå?              
                         ''')
            st.caption('* Ìï¥Îãπ Ï£ºÏùò Ï†ÑÏ≤¥ DAUÍ∞Ä WAU Î≥¥Îã§ ÎÜíÏùÄ Í≤ΩÏö∞ : Ïû¨Î∞©Î¨∏ÌïòÎäî ÎèÖÏûêÎì§Ïù¥ ÎßéÏùÄÍ≤ÉÏúºÎ°ú Î≥º Ïàò ÏûàÏäµÎãàÎã§.  ')

            #--------------------------------- Ïû¨Î∞©Î¨∏ Í∑∏ÎûòÌîÑ ---------------------------------------------- #

            dau = dau.rename(columns={'user_id':'dau'})
            dau['comment_date'] = pd.to_datetime(dau['comment_date'], errors='coerce')
            dau['week'] = dau['comment_date'].dt.to_period('W').dt.start_time.dt.date
            dau['month'] = dau['comment_date'].dt.to_period('M').dt.start_time.dt.date

            dw = pd.merge(dau, wau, left_on='week', right_on='comment_date', how='inner')
            dw = dw.rename(columns={'user_id': 'wau','comment_date':'week','comment_date_x':'day'}).drop(columns=['comment_date_y']) 
            dw['dau_sum'] = dw.groupby(['week'])['dau'].transform('sum')
            dw['dau_wau_diff'] = dw['dau_sum'] - dw['wau']
            dw= dw.drop_duplicates(subset=['week'])[['week','dau_sum','wau','dau_wau_diff']]


            # chort_df = comment_data.copy()
            # chort_df.set_index('user_id', inplace=True)
            # Ïú†Ï†ÄÎ≥Ñ Ï≤´ Ï∞∏Ïó¨Í∏∞Í∞Ñ Ï∂îÏ∂ú
            # chort_df['CohortGroup'] = chort_df.groupby(level=0)['comment_date'].min().apply(lambda x: x.strftime('%Y-%m'))
            # chort_df.reset_index(inplace=True)


# ------------------------------------------------------ ÎåìÍ∏Ä Îç∞Ïù¥ÌÑ∞Î•º Í∏∞Ï§ÄÏúºÎ°ú Ïú†Ï†Ä Í≥†Ï∞©ÎèÑÎ•º Íµ¨Ìï¥Î≥¥Ïûê --------------------------------------------- #




        st.header('Stickiness ')
        st.caption(''' Ìï¥Îãπ ÏõπÌà∞ÏùÄ ÏïÑÏßÅ Ïó∞Ïû¨ÏùºÏù¥ 1ÎÖÑÏù¥ ÏïàÎêú ÏõπÌà∞ÏûÖÎãàÎã§. ÎòêÌïú Ï£ºÏóê 2Î≤à Ïó∞Ïû¨ÎêòÎäî ÏûëÌíà ÌäπÏÑ±ÏÉÅ ÌôúÏÑ±Ìôî Ïú†Ï†Ä ÎòêÌïú Ìï¥Îãπ Ïó∞Ïû¨ÏùºÏóê Ï£ºÎ°ú Îì§Ïñ¥Ïò§Îäî Í≤ΩÌñ•Ïù¥ ÏûàÍ∏∞ ÎïåÎ¨∏Ïóê
                    wauÎ•º ÎÇòÎà†ÏÑú Íµ¨ÌïòÎäîÍ≤ÉÏù¥ Ï†ÅÏ†àÌï¥ Î≥¥ÏòÄÏäµÎãàÎã§.
                    ''')



        # Ï£ºÍ∞Ñ stick Íµ¨ÌïòÍ∏∞ 
        # ÏùºÎã®, Ìï¥Îãπ ÏöîÏùºÏù¥ Ïñ¥Îäê Ï£ºÏù∏ÏßÄ filter ÌïÑÏöî
        # Ìï¥Îãπ ÌÖåÏù¥Î∏îÏóê wau merge   
        stick_df = pd.merge(dau, wau, left_on='week', right_on='comment_date', how='inner')
        stick_df = stick_df.rename(columns={'user_id': 'wau','comment_date':'week','comment_date_x':'day'}).drop(columns=['comment_date_y']) 
        stick_df['week_stick'] = round(stick_df['dau'] / stick_df['wau'],2) * 100
        stick_df['week_stick'] = stick_df['week_stick'].astype(int)
        


        # Ïó∞Ïû¨ÎêòÎäî ÎÇ†ÏßúÏùò Ïú†Ï†Ä Í≥†Ï∞©ÎèÑ Íµ¨ÌïòÍ∏∞
        def Stickiness(stick_df ,day):
            Stickiness = stick_df[stick_df['day_name'].isin(day)]
            Stickiness['week'] = pd.to_datetime(Stickiness['week']).dt.strftime('%Y-%m-%d')
            Stickiness = Stickiness.groupby(['week']).agg(
                week_stick_mean = pd.NamedAgg(column='week_stick', aggfunc='mean')                                                   
                                                    ).reset_index()
            Stickiness['week_stick_mean'] = round(Stickiness['week_stick_mean'])

            # (Ïó∞Ïû¨ÎêòÎäî ÎÇ†Ïùò)ÌèâÍ∑† Í≥†Ï∞©ÎèÑ
            mean_stick = round(Stickiness['week_stick_mean'].mean())

            # Îç∞Ïù¥ÌÑ∞ Î≥ÄÌôò
            nivo_data = []
            for index, row in Stickiness.iterrows():
                nivo_data.append({'x': row['week'], 'y': row['week_stick_mean']})

            nivo_data = [{
                "id": "stickness",
                "data": nivo_data
            }]
            return mean_stick, nivo_data



        col1, col2 = st.columns([3,1])
        with col1:
            st.markdown('''#### üìä Stickness ''' )
            mean_stick, nivo_data =  Stickiness(stick_df, day = list(calendar.day_name))
            title = 'ÏöîÏùºÎ≥Ñ' 
            on = st.toggle('(Ïó∞Ïû¨Ïùº) Stickness')
            if on:
                mean_stick, nivo_data =  Stickiness(stick_df, day = ['Sunday','Wednesday'])
                title = 'Ïó∞Ïû¨Ïùº'





            with st.container():       
                    with elements("playlist_line_chart"):
                        layout = [
                            dashboard.Item("item_1", 0, 0, 12, 2),
                        ]

                        with dashboard.Grid(layout):                                                            
                            mui.Box(                                        
                                nivo.Line(
                                    data= nivo_data,
                                    margin={'top': 40, 'right': 30, 'bottom': 30, 'left': 30},
                                    # xScale={'type': 'point',
                                    #         },

                                    curve="monotoneX",
                                    axisTop=None,
                                    axisRight=None,
                                    axisBottom={
                                        'format': '%y-%m-%d',  # '%Y-%m-%d'
                                        'legendOffset': -12,
                                        'tickValues': 'every 30 days'
                                    },
                                    xFormat="time:%Y-%m-%d",
                                    xScale={
                                        'format': '%Y-%m-%d',
                                        'precision': 'day',
                                        'type': 'time',
                                        # 'useUTC': False
                                    },
                                    colors= {'scheme': 'accent'},

                                    enableGridX = False,
                                    enableGridY = False,
                                    enableArea = True,
                                    areaOpacity = 0.2,
                                    lineWidth=2,
                                    pointSize=3,
                                    pointColor='white',
                                    pointBorderWidth=0.5,
                                    pointBorderColor={'from': 'serieColor'},
                                    pointLabelYOffset=-12,
                                    useMesh=True,
                                    legends=[
                                                {
                                                'anchor': 'top-left',
                                                'direction': 'column',
                                                'justify': False,
                                                # 'translateX': -30,
                                                # 'translateY': -200,
                                                'itemsSpacing': 0,
                                                'itemDirection': 'left-to-right',
                                                'itemWidth': 80,
                                                'itemHeight': 15,
                                                'itemOpacity': 0.75,
                                                'symbolSize': 12,
                                                'symbolShape': 'circle',
                                                'symbolBorderColor': 'rgba(0, 0, 0, .5)',
                                                'effects': [
                                                        {
                                                        'on': 'hover',
                                                        'style': {
                                                            'itemBackground': 'rgba(0, 0, 0, .03)',
                                                            'itemOpacity': 1
                                                            }
                                                        }
                                                    ]
                                                }
                                            ],                            
                                    theme={
                                            # "background-color": "rgba(158, 60, 74, 0.2)",
                                            "textColor": "black",
                                            "tooltip": {
                                                "container": {
                                                    "background": "#3a3c4a",
                                                    "color": "white",
                                                }
                                            }
                                        },
                                    markers=[{                                                
                                        'axis': 'y',
                                        'legend': 'mean',
                                        'lineStyle': {
                                            'stroke': '#b0413e',
                                            'strokeWidth': 1
                                        },
                                        'value': mean_stick                                                
                                    }] ,                                             
                                    animate= False)
                                    ,key="item_1",sx={"borderRadius":"15px", "borderRadius":"15px","background-color":"#F0F2F6"}) 





        with col2:
            
            st.write(f''' 
                    #### {title} ÌèâÍ∑† stickiness (ÎßâÎåÄÏ∞®Ìä∏)                     
                    * ÏßÄÎ∞úÎãòÏùò ÏûëÌíà 'Î¨¥ÏßÅÎ∞±Ïàò Í≥ÑÎ∞±Ïàú'Ïùò ÌèâÍ∑† Í≥†Ï∞©ÎèÑ(DAU/WAU)Îäî <strong style="color:#75D060"> {mean_stick}% </strong>ÏûÖÎãàÎã§.  
                    * ÌÅ∞ Î≥ÄÎèô ÏóÜÏù¥ 7Ïùº Ï§ë ÌèâÍ∑† <strong style="color:#75D060"> {(mean_stick/100)*7}Î≤à </strong> ÎåìÍ∏ÄÏùÑ ÎÇ®Í∏∞Í≥† ÏûàÏäµÎãàÎã§.  
                    * Ìïú Ï£ºÎãπ 2Î≤à Ïó∞Ïû¨ÎêòÎäî ÏõπÌà∞ ÏãúÏä§ÌÖúÏùÑ Í≥†Î†§ÌïúÎã§Î©¥ Ï§ÄÏàòÌïú ÏÉÅÌÉúÎùºÍ≥† ÏÉùÍ∞ÅÌï©ÎãàÎã§. 
                     ''',unsafe_allow_html=True )  


    



    # ---------------------------------------------------------------- ÎèÖÏûêÎì§Ïù¥ ÏÑúÎπÑÏä§Î•º Ïù¥Ïö©ÌïòÎäî ÏãúÍ∞ÑÎåÄ ---------------------------------------------------------------- #
    with st.container():
        st.subheader(''' 
                    ü§î ÎèÖÏûêÎì§Ïù¥ Í∞ÄÏû• ÎßéÏù¥ Î≥¥Îäî ÏãúÍ∞ÑÎåÄÎäî Ïñ∏Ï†úÏù∏Í∞ÄÏöî?
                    ''')
        st.caption(''' 
                * ÏõπÌà∞Ïùò Ï°∞ÌöåÏàòÏóê ÎåÄÌïú Ï†ïÌôïÌïú Í∞íÏùÄ Ïïå Ïàò ÏóÜÏóàÏäµÎãàÎã§. ÌïòÏßÄÎßå Ï°∞ÌöåÏàòÏôÄ ÎåìÍ∏ÄÍ∞ÑÏùò ÏÉÅÍ¥ÄÏÑ±ÏùÄ Îß§Ïö∞ ÎÜíÏúºÎ©∞ Ïù¥Ïóê Îî∞Îùº ÎèÖÏûêÎì§Ïùò Ï∞∏Ïó¨ÎèÑ ÏßÄÌëúÏù∏ 'ÎåìÍ∏Ä'ÏùÑ ÎÇ®Í∏¥ÏãúÍ∞ÑÏùÑ Ïù¥Ïö©ÌïòÏó¨ Ïù¥Ïö© ÏãúÍ∞ÑÎåÄÎ•º Íµ¨ÌñàÏäµÎãàÎã§. 
                    ''')

        comment_data['hour'] = comment_data['comment_date'].dt.hour #.strftime("%Y-%m-%d %H:%M:%S")

        comment_group_by_hour = comment_data.groupby(['hour']).agg(        
            cnt = pd.NamedAgg(column='hour',aggfunc='count'))

        st.line_chart(comment_group_by_hour, use_container_width=True)
        st.write('''
                  Ï£ºÎ°ú **ÏõπÌà∞Ïù¥ ÏóÖÎ°úÎìúÍ∞Ä ÎêòÎäî ÏãúÍ∞ÑÎåÄÏù∏ Î∞§(11Ïãú)Î∂ÄÌÑ∞ ÏÉàÎ≤Ω ÏãúÍ∞ÑÎåÄ**Ïóê Í∞ÄÏû• ÎßéÏùÄ ÎèÖÏûêÎì§Ïù¥ Ï†ëÏÜçÌï®ÏùÑ Î≥º Ïàò ÏûàÏóàÏñ¥Ïöî! 
                 ÎòêÌïú ÏÉÅÎåÄÏ†ÅÏúºÎ°ú ÏôÑÎßåÌïòÏßÄÎßå **Ïò§Ï†Ñ ÏãúÍ∞ÑÎåÄ(6Ïãú~8Ïãú)** Í∑∏Î¶¨Í≥† Ï†êÏã¨ ÏãúÍ∞ÑÎåÄ(12Ïãú)Ïóê ÎßéÏùÄ ÏõπÌà∞ÏùÑ Î≥¥Îäî ÎèÖÏûêÎì§Ïù¥ ÏûàÏóàÏäµÎãàÎã§. ''')



        # ÏõπÌà∞ÏùÑ Î≥¥Îäî ÏãúÍ∞Ñ (ÏïÑÏπ® Ï†êÏã¨ Î∞§) Ïú†Ï†Ä ÎπÑÏú®
        comment_data['morning'] = 0
        comment_data['day'] = 0
        comment_data['night'] = 0

        comment_data.loc[comment_data['hour'].between(6, 11), 'morning'] = 1
        comment_data.loc[comment_data['hour'].between(12, 18), 'day'] = 1
        comment_data.loc[~comment_data['hour'].between(6, 18), 'night'] = 1


        user_timeinfo = comment_data.groupby(['user_id']).agg(
                    morning = pd.NamedAgg(column='morning',aggfunc='sum'),
                    day = pd.NamedAgg(column='day',aggfunc='sum'),
                    night = pd.NamedAgg(column='night',aggfunc='sum')
                )



        st.divider()




    # -------------------------------------------------------------- ltv ÏÇ∞Ï∂úÌïòÍ∏∞ -------------------------------------------------------------------------------------- #
    with st.container():
        
        st.header('üèÖ LTV ÌôúÏö©ÌïòÍ∏∞')
        st.markdown(''' 
                    #### ‚úîÔ∏è Î∞§Ïóê ÎπÑÌï¥ Ïò§Ï†Ñ, ÎÇÆÏãúÍ∞ÑÎåÄÏùò UVÍ∞Ä Ï†ÅÏùÄ Í≤ÉÏùÑ Î≥º Ïàò ÏûàÏóàÏäµÎãàÎã§.            
                    > Ïò§Ï†Ñ/ÎÇÆ ÏãúÍ∞ÑÎåÄÏùò UV ÌôïÎ≥¥ÌïòÍ∏∞ ÏúÑÌï¥ **'Îì±Íµê, Ï∂úÍ∑ºÌïòÎäî ÏãúÍ∞ÑÎåÄÏóê ÎßûÏ∂ò nÎ∂Ñ Î¨¥Î£åÎ≥¥Í∏∞ Î∞è Ïø†ÌÇ§ Ï°∞Ï°∞Ìï†Ïù∏ ÌòúÌÉù Í¥ëÍ≥† ÏïåÎ¶º'** ÌîÑÎ°úÎ™®ÏÖòÏùÑ ÏßÑÌñâÌïòÎ†§Í≥† ÌïòÎäîÎç∞Ïöî! Ïù¥Î≤§Ìä∏Î•º ÏßÑÌñâÌï† ÏòàÏÇ∞ÏùÑ Ìö®Ïú®Ï†ÅÏúºÎ°ú ÏÇ¨Ïö©ÌïòÏó¨ Î™©ÌëúÎ•º Îã¨ÏÑ±Ìï† Ïàò ÏûàÎäî Î∞©Î≤ïÏù¥ ÏûàÏùÑÍπåÏöî?  
                    > Ïù¥Î•º ÏúÑÌï¥, ÎèÖÏûêÎì§Ïù¥ Ï£ºÎ°ú **Ïù¥Ïö©ÌïòÎäî ÏãúÍ∞ÑÎåÄ**Ïùò Í∑∏Î£πÏùÑ ÎÇòÎàÑÍ≥†  LTVÎ•º ÌôúÏö©ÌïòÏó¨ **ÎØ∏ÎûòÍ∞ÄÏπòÍ∞Ä ÎÜíÏùÄ ÎèÖÏûê**Îì§ÏùÑ ÏÑ†Î≥ÑÌï¥ Ïù¥Î≤§Ìä∏Î•º ÏßÑÌñâÌï¥Î≥¥Î†§Í≥† Ìï©ÎãàÎã§.

                     ''')


        # st.write('''
        #          Ìï¥Îãπ ÏÑúÎπÑÏä§ÏóêÏÑú LTVÎ•º Íµ¨Ìï¥ÏïºÌïòÎäî Ïù¥Ïú†Îäî Î≠òÍπå? Î®ºÏ†Ä Ìï¥Îãπ ÏÑúÎπÑÏä§Ïùò ÏàòÏùµ Î™®Îç∏ÏùÑ ÌôïÏù∏Ìï¥Î≥¥Ïûê.

        #          ‚ë† ÏàòÏùµÏÑ± Î∂ÑÎ∞∞ PPS(Page Profit Share)Î™®Îç∏  
        #          ÏõπÌà∞ ÌïòÎã®Ïùò Ïù¥ÎØ∏ÏßÄ Í¥ëÍ≥†, ÎØ∏Î¶¨Î≥¥Í∏∞ Ïú†Î£å ÌåêÎß§ ÏàòÏùµ, ÎìúÎùºÎßà/ÏòÅÌôî ÏòÅÏÉÅÌôî, IP(ÏßÄÏ†Å Ïû¨ÏÇ∞Í∂å)Í∏∞Î∞ò ÎπÑÏ¶àÎãàÏä§Î•º ÌÜµÌï¥ ÏàòÏùµÏ∞ΩÏ∂ú                              
        #          ‚ë° Î∂ÄÎ∂Ñ Ïú†Î£åÌôî ÏàòÏùµ Î™®Îç∏  
        #          Ïø†ÌÇ§Î•º Í≤∞Ï†úÌïòÏó¨ ÏïÑÏßÅ Ïó∞Ïû¨ÎêòÏßÄ ÏïäÏùÄ ÏóêÌîºÏÜåÎìúÎ•º Î≥º Ïàò ÏûàÏùå.
                
        #         > "Í¥ëÍ≥† ÎÖ∏Ï∂úÏàò" = "ÏõπÌà∞ Ï°∞ÌöåÏàò" = "ÏàòÏùµ Ï∞ΩÏ∂ú" ÌÅ∞ ÏÉÅÍ¥ÄÏÑ±Ïù¥ ÏûàÎã§.

        #          ''')

        st.caption(''' Ï¢Ä Îçî Ï†ïÌôïÌïú LTVÎ•º ÏÇ∞Ï∂úÌïòÍ∏∞ ÏúÑÌï¥ ÎèÖÏûêÎ≥Ñ **Ïø†ÌÇ§(Ïú†Î£åÍ≤∞Ï†ú)Î•º Ïù¥Ïö© Ïó¨Î∂Ä**Î•º Ï∂îÍ∞ÄÌñàÏäµÎãàÎã§. Ïø†ÌÇ§Î•º Í≤∞Ï†úÌïú Ïú†Ï†ÄÎì§Ïùò Ï†ïÎ≥¥Î•º 100% Ïïå Ïàò ÏóÜÏóàÏßÄÎßå ÎåìÍ∏Ä Îç∞Ïù¥ÌÑ∞Î•º Ïù¥Ïö©ÌïòÏó¨ Ïú†Ï∂îÌï† Ïàò ÏûàÏóàÏäµÎãàÎã§.  
            Î∞îÎ°ú <strong style="color:#6BC55C"> 'ÏõπÌà∞Ïù¥ ÏóÖÎ°úÎìúÎêú ÎÇ†Ïßú'ÏôÄ 'ÎåìÍ∏ÄÏù¥ ÏûëÏÑ±Îêú ÎÇ†Ïßú'Î•º Ïù¥Ïö©</strong>ÌïòÎäî Í≤ÉÏù¥Ï£†.
            ÎßåÏïΩ, '2024-03-01'Ïóê ÏóÖÎ°úÎìúÎêú ÏûëÌíàÏù¥ ÏûàÎã§Î©¥, Ïú†Î£åÍ≤∞Ï†úÎ•º ÌïòÏßÄ ÏïäÏùÄ ÏÇ¨ÎûåÏùò Í≤ΩÏö∞ ÏóÖÎ°úÎìúÎêú ÎÇ†Ïßú Ïù¥ÌõÑÏóê ÎåìÍ∏ÄÏùÑ ÎÇ®Í∏∏ Ïàò ÏûàÏäµÎãàÎã§.  
            ÌïòÏßÄÎßå **Ïø†ÌÇ§Î•º Ïù¥Ïö©ÌïòÏó¨ ÎØ∏Î¶¨Î≥¥Í∏∞Î•º Ìïú Ïú†Ï†ÄÏùò Í≤ΩÏö∞ ÏóÖÎ°úÎìú ÎÇ†Ïßú(2024-03-01) Ïù¥Ï†ÑÏóê ÏõπÌà∞ÏùÑ Î≥¥Í≥† ÎåìÍ∏ÄÏùÑ ÏûëÏÑ±**ÌñàÏùÑ Í≤ÉÏûÖÎãàÎã§! <strong style="color:#6BC55C">Ï¶â, 'ÏõπÌà∞Ïù¥ Í≤åÏãúÎêú ÎÇ†Ïßú' > 'ÎåìÍ∏ÄÏù¥ ÏûëÏÑ±Îêú ÎÇ†Ïßú'Ïù∏ Í≤ΩÏö∞ 'Ïø†ÌÇ§Î•º ÏÇ¨Ïö©Ìïú ÎèÖÏûê' Î°ú ÌåêÎã®</strong>ÌñàÏäµÎãàÎã§. 
            ''', unsafe_allow_html=True)

        info = main_data.drop_duplicates(subset=['episode'])[['chapter','episode','upload_at']]
        ltv_df = pd.merge(comment_data, info, on='episode',how='left')
        ltv_df['cookie'] = np.where(ltv_df['comment_date'] < ltv_df['upload_at'], 1200, 0)
        ltv_df['price'] = ltv_df['cookie'] + ltv_df['comment_like'] + 500 

        current_date = ltv_df['comment_date'].max()
        ltv_df['comment_date'] = pd.to_datetime(ltv_df['comment_date']).dt.date


        metrics_df = summary_data_from_transaction_data(ltv_df
                                                , customer_id_col = 'user_id'
                                                , datetime_col = 'comment_date'
                                                , monetary_value_col='price'
                                                , observation_period_end=current_date).reset_index()




        # ÏïΩ 8Í∞úÏõî(240) Îç∞Ïù¥ÌÑ∞, holdout_Days 1/8
        # train, test set Î∂ÑÎ¶¨ -  liftime ÏóêÏÑúÎäî calibration/holdout ÏúºÎ°ú Î∂ÑÎ¶¨ÌïúÎã§.(Î™ÖÏπ≠Îßå Îã§Î•¥Îã§)
        holdout_days = 30
        calibration_end_date = current_date - datetime.timedelta(days = holdout_days)

        metrics_cal_df = calibration_and_holdout_data(ltv_df
                                                ,customer_id_col = 'user_id'
                                                ,datetime_col = 'comment_date'
                                                ,calibration_period_end=calibration_end_date # train Îç∞Ïù¥ÌÑ∞ Í∏∞Í∞Ñ
                                                ,observation_period_end=current_date         # ÎÅù Í∏∞Í∞Ñ
                                                ,monetary_value_col='price')

        # frequencyÍ∞Ä 0Ïù∏ Í≤ÉÏùÄ Ï†úÏô∏ÌïòÍ∏∞
        whole_filtered_df = metrics_df[metrics_df.frequency > 0]
        filtered_df       = metrics_cal_df[metrics_cal_df.frequency_cal > 0]


        # ÌèâÍ∞Ä ÏßÄÌëú: defaultÎäî MSE
        def score_model(actuals, predicted, metric='mse'):

            metric = metric.lower()

            # MSE / RMSE
            if metric=='mse' or metric=='rmse':
                val = np.sum(np.square(actuals-predicted))/actuals.shape[0]
            elif metric=='rmse':
                val = np.sqrt(val)
            # MAE
            elif metric=='mae':
                val = np.sum(np.abs(actuals-predicted))/actuals.shape[0]
            else:
                val = None

            return val

        # BG/NBD Î™®Ìòï ÌèâÍ∞Ä
        def evaluate_bgnbd_model(param,data):

            l2_reg = param

            # Î™®Ìòï Ï†ÅÌï©
            model = BetaGeoFitter(penalizer_coef=l2_reg)
            model.fit(data['frequency_cal'], data['recency_cal'], data['T_cal'])

            # Î™®Ìòï ÌèâÍ∞Ä
            frequency_actual = data['frequency_holdout']
            frequency_predicted = model.predict(data['duration_holdout']
                                                , data['frequency_cal']
                                                , data['recency_cal']
                                                , data['T_cal']
                                            )
            mse = score_model(frequency_actual, frequency_predicted, 'mse')

            return {'loss': mse, 'status': STATUS_OK}

        # Gamma/Gamma Î™®Îç∏ ÌèâÍ∞Ä
        def evaluate_gg_model(param,data):

            l2_reg = param

            # GammaGamma Î™®Ìòï Ï†ÅÌï©
            model = GammaGammaFitter(penalizer_coef=l2_reg)
            model.fit(data['frequency_cal'], data['monetary_value_cal'])

            # Î™®Ìòï ÌèâÍ∞Ä
            monetary_actual = data['monetary_value_holdout']
            monetary_predicted = model.conditional_expected_average_profit(data['frequency_holdout'], data['monetary_value_holdout'])
            mse = score_model(monetary_actual, monetary_predicted, 'mse')

            # return score and status
            return {'loss': mse, 'status': STATUS_OK}


        # BG/NBD ÏµúÏ†Å L2 penalty
        @st.cache_resource
        def best_L2_penalty(filtered_df):
            def evaluate_bgnbd_wrapper(param):
                return evaluate_bgnbd_model(param, filtered_df)
            def evaluate_gg_wrapper(param):
                return evaluate_gg_model(param, filtered_df)

            search_space = hp.uniform('l2', 0.0, 1.0)
            algo = tpe.suggest
            trials = Trials()

            argmin_bgnbd = fmin(
                fn=evaluate_bgnbd_wrapper,
                space=search_space,
                algo=algo,
                max_evals=100,
                trials=trials
            )
            
            # GammaGamma ÏµúÏ†Å L2 penalty
            trials = Trials()
            argmin_gg = fmin(
            fn = evaluate_gg_wrapper,
            space = search_space,
            algo = algo,
            max_evals=100,
            trials=trials
            )

            l2_bgnbd = space_eval(search_space, argmin_bgnbd)
            l2_gg = space_eval(search_space, argmin_gg)

            return l2_bgnbd, l2_gg
        
        # L2 penaltyÎ•º Ï†ÅÏö©ÌïòÏó¨ Í∞ÅÍ∞ÅÏùÑ Î™®Îç∏ÎßÅ
        @st.cache_resource
        def bgnbd_model(l2_bgnbd):
            lifetimes_model = BetaGeoFitter(penalizer_coef=l2_bgnbd) #l2_bgnbd = hyperoptÎ°ú ÎÇòÏò® Í≤∞Í≥ºÏ†ÅÏö©
            # calibration Îç∞Ïù¥ÌÑ∞Ïùò R,F,TÎ°ú Î™®Ìòï Ï†ÅÌï©
            lifetimes_model.fit(filtered_df['frequency_cal'], filtered_df['recency_cal'], filtered_df['T_cal']) 

            # holdout Îç∞Ïù¥ÌÑ∞Î°ú Î™®Îç∏ ÌèâÍ∞Ä: FÏùò Ïã§Ï†úÍ∞íÍ≥º ÏòàÏ∏°Í∞íÏùò MSE
            frequency_actual = filtered_df['frequency_holdout']
            frequency_predicted = lifetimes_model.predict(filtered_df['duration_holdout']
                                                ,filtered_df['frequency_cal']
                                                , filtered_df['recency_cal']
                                                , filtered_df['T_cal'])
            frequency_mse = score_model(frequency_actual, frequency_predicted, 'mse')
            return lifetimes_model, frequency_mse  #st.write('Íµ¨Îß§ÌöüÏàòÏóêÎåÄÌïú Ï†úÍ≥±Ïò§Ï∞®: {0}'.format(frequency_mse))

        @st.cache_resource
        def gg_model(l2_gg):

            # gammagamma Î™®Îç∏ÏùÑ Ïù¥Ïö©ÌïòÏó¨ ÎØ∏Îûò Íµ¨Îß§ Í∏àÏï° Íµ¨ÌïòÍ∏∞
            spend_model = GammaGammaFitter(penalizer_coef=l2_gg)
            spend_model.fit(filtered_df['frequency_cal'], filtered_df['monetary_value_cal'])
            # conditional_expected_average_profit: Í≥†Í∞ùÎ≥Ñ ÌèâÍ∑† Íµ¨Îß§ Í∏àÏï° ÏòàÏ∏°
            monetary_actual = filtered_df['monetary_value_holdout']
            monetary_predicted = spend_model.conditional_expected_average_profit(filtered_df['frequency_holdout']
                                                                                ,filtered_df['monetary_value_holdout'])

            monetary_mse = score_model(monetary_actual, monetary_predicted, 'mse')
            return spend_model, monetary_mse

        # l2_bgnbd, l2_gg = best_L2_penalty(filtered_df)
        lifetimes_model, frequency_mse= bgnbd_model(0.001322590266385021) # BG/NBD l2 ÌéòÎÑêÌã∞Í∞í
        spend_model, monetary_mse = gg_model(0.0018085768788633095) #  GammaGamma l2 ÌéòÎÑêÌã∞Í∞í





        # LTV table COl

        col1,col2 = st.columns([1,2])
        with col1:
            st.markdown('''##### üìÅÏø†ÌÇ§Î•º ÏÇ¨Ïö©Ìïú Ïú†Ï†ÄÏùò ÌÖåÏù¥Î∏î(ÏùºÎ∂Ä) ''')

            expander = st.expander('ÎèÖÏûê Price Í∏∞Ï§Ä')
            with expander:
                st.caption('''
                        Monetary ÏÇ∞Ï∂úÏùÑ ÏúÑÌïú Ïú†Ï†Ä ÏÇ¨Ïö© Í∏àÏï°(price)ÏùÑ Îã§ÏùåÍ≥º Í∞ôÏù¥ Ï†ïÏùò ÌñàÏäµÎãàÎã§.
                        (Ïã§Ï†ú Ïø†ÌÇ§Ïùò Í∞ÄÍ≤©ÏùÄ Í∞úÎãπ 120Ïõê Ïù¥ÏßÄÎßå Í∑πÏ†ÅÏù∏ ÌëúÌòÑÏùÑ ÏúÑÌï¥ 1200ÏõêÏúºÎ°ú Ï°∞Ï†ï)
                           
                        * Ïø†ÌÇ§ 1Í∞ú Ïù¥Ïö© = 1200ÏõêÏùò Í∞ÄÏπò                                               
                        * Î∞õÏùÄ Ï¢ãÏïÑÏöî = Í∞úÎãπ 1ÏõêÏùò Í∞ÄÏπò  
                        * ÎåìÍ∏Ä ÏûëÏÑ±Ïàò = Í∞úÎãπ 500ÏõêÏùò Í∞ÄÏπò  
                           
                        Ïú†Î£åÍ≤∞Ï†ú ÎøêÎßå ÏïÑÎãàÎùº 'ÎåìÍ∏Ä'Í≥º 'ÎåìÍ∏Ä Ï¢ãÏïÑÏöî' ÎòêÌïú ÏûëÌíàÏùò Í¥ÄÏã¨, Ïù∏Í∏∞ÎèÑÏóê ÏòÅÌñ•ÏùÑ ÎØ∏ÏπòÎäî Ï§ëÏöîÌïú ÏßÄÌëúÎùºÍ≥† ÏÉùÍ∞ÅÌï©ÎãàÎã§.
                        Í∞ÄÏû• Î®ºÏ†Ä Î≥¥Ïó¨ÏßÄÎäî Î≤†Ïä§Ìä∏ ÎåìÍ∏ÄÏùÑ Î≥¥Í≥† Îòê Îã§Î•∏ ÎåìÍ∏ÄÏùÑ ÎÇ®Í∏∞Í∏∞ÎèÑ ÌïòÍ≥†, Ï¢ãÏïÑÏöîÎ•º ÎàÑÎ•¥Í∏∞ÎèÑ ÌïòÎ©¥ÏÑú ÎèÖÏûêÎì§Ïùò Ï∞∏Ïó¨ÎèÑÎ•º Ïù¥ÎÅåÏñ¥ ÎÇ¥Îäî ÏßÄÌëúÎùºÍ≥† ÏÉùÍ∞ÅÌñàÍ∏∞ ÎïåÎ¨∏Ïóê Í∏àÏï°ÏúºÎ°ú ÌôòÏÇ∞ÌïòÏó¨ ÏßëÍ≥Ñ ÌñàÏäµÎãàÎã§.
                        ''')
        
                st.write(ltv_df[ltv_df['cookie'] == 1200][['episode','upload_at','user_id','comment_date','comment_like','cookie','price']].sample(5))

            # Ï¢ãÏïÑÏöîÍ∞Ä ÎßéÎã§Îäî Í≤ÉÏùÄ ÎèÖÏûêÎì§Ïù¥ Ìï¥Îãπ ÎåìÍ∏ÄÏóê Í≥µÍ∞êÌïòÍ≥†, ÎèôÏ°∞Ìï† ÌôïÎ•†Ïù¥ ÎÜíÎã§Îäî ÏûêÎ£åÍ∞Ä ÏûàÎã§. Ìï¥Îãπ ÏûëÌíàÏóê ÏòÅÌñ•ÏùÑ ÎØ∏ÏπòÎäî Ï§ëÏöîÌïú ÏßÄÌëúÎùºÍ≥† ÏÉùÍ∞ÅÎêòÏóàÏäµÎãàÎã§.
            # Î≤†Ïä§Ìä∏ÎåìÍ∏ÄÏóê Îòê Îã§Î•∏ ÎåìÍ∏ÄÏùÑ ÎÇ®Í∏∞Í∏∞ÎèÑ ÌïòÍ≥†, Ï¢ãÏïÑÏöîÎ•º ÎàåÎ•¥Í∏∞ÎèÑÌïòÎäî Ïù¥Îü∞ ÎèÖÏûêÎì§Ïùò Ï∞∏Ïó¨ÎèÑÎ•º Ïù¥ÎÅåÏñ¥ ÎÇº Ïàò ÏûàÎäî ÏßÄÌëúÎùºÍ≥† ÏÉùÍ∞ÅÌñàÍ∏∞ ÎïåÎ¨∏Ïóê Í∏àÏ†ÑÏ†ÅÏù∏ Í∞ÄÏπòÍ∞Ä Ïñ¥ÎäêÏ†ïÎèÑ ÏûàÎã§Í≥† ÌåêÎã®ÌñàÏäµÎãàÎã§.



        ### LTV ÌÖåÏù¥Î∏î
        with col2:
            st.markdown('''##### üìÅLTV ÌÖåÏù¥Î∏î ''')
            expander = st.expander('LTV ÏÇ∞Ï∂ú Î∞©Î≤ï')
            with expander:
                st.caption(f'''
                            BG/NBD, GammaGamma Î™®Îç∏ÏùÑ Ïù¥Ïö©ÌïòÏó¨ 8Í∞úÏõî ÎèôÏïàÏùò LTV, ÏòàÏÉÅ Íµ¨Îß§ÌöüÏàò Î∞è Í∏àÏï°ÏùÑ ÏÇ∞Ï∂úÌï¥Î≥¥ÏïòÏäµÎãàÎã§.  

                            * Frequency : ÏñºÎßàÎÇò ÏûêÏ£º Íµ¨Îß§(Ï∞∏Ïó¨) ÌñàÎäîÏßÄ 
                            * Recency : ÏµúÍ∑ºÏóê Íµ¨Îß§(Ï∞∏Ïó¨) ÌñàÎäîÏßÄ 
                            *  T : Í≥†Í∞ùÎ≥Ñ Ï≤´ Íµ¨Îß§(Ï∞∏Ïó¨) ~ ÏßëÍ≥ÑÏùºÍπåÏßÄÏùò ÏãúÍ∞Ñ
                            * ÏòàÏ∏° Íµ¨Îß§ ÌöüÏàòÏùò ÌèâÍ∑† Ï†úÍ≥±Ïò§Ï∞® : ¬±{round(frequency_mse,3)}Ïùº
                            * ÏòàÏ∏° Íµ¨Îß§ Í∏àÏï°Ïùò ÌèâÍ∑† Ï†úÍ≥±Ïò§Ï∞® : ¬±{round(monetary_mse,3)}Ïõê
                            * ÏÇ∞Ï∂úÎêú LTV Í∞íÏóê Îî∞Îùº ÏÑ∏Í∑∏Î®ºÌä∏ ÎÇòÎàÑÍ∏∞ : (ÏÉÅÏúÑ20%) diamond , (20-40) platinum, (40-60) gold, (ÎÇòÎ®∏ÏßÄ) silver

                        ''')



                final_df = whole_filtered_df.copy() #  Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞Î•º ÎåÄÏÉÅÏúºÎ°ú LTVÏÇ∞Ï∂ú
                final_df['ltv'] = spend_model.customer_lifetime_value(lifetimes_model,
                                                                    final_df['frequency'],
                                                                    final_df['recency'],
                                                                    final_df['T'],
                                                                    final_df['monetary_value'],
                                                                    time=8, # Î™áÍ∞úÏõî ÎèôÏïàÏùò ltvÎ•º Î≥ºÍ≤ÉÏù∏ÏßÄ , 8Í∞úÏõî 
                                                                    #discount_rate=0.01 # monthly discount rate ~12.7% Ïó∞Í∞Ñ
                                                                    )


                # 8Í∞úÏõî ÎèôÏïàÏùò ÏòàÏÉÅ Íµ¨Îß§ÌöüÏàò
                t=240 
                final_df['predicted_purchases'] = lifetimes_model.conditional_expected_number_of_purchases_up_to_time(t
                                                                                                    , final_df['frequency']
                                                                                                    , final_df['recency']
                                                                                                    , final_df['T'])
                # 8Í∞úÏõî ÎèôÏïàÏùò ÏòàÏÉÅ Íµ¨Îß§Í∏àÏï°
                final_df['predicted_monetary_value'] = spend_model.conditional_expected_average_profit(final_df['frequency']
                                                                                    ,final_df['monetary_value'])


                # ÎèÖÏûê ÏÑ∏Í∑∏Î®ºÌä∏ ÎÇòÎàÑÍ∏∞
                final_df['segment'] = 0 # pd.qcut(final_df['ltv'], 5 , labels=['bronze','silver', 'gold','platinum','diamond'])

                quantiles = final_df['ltv'].quantile([0.8, 0.6, 0.4])
                final_df.loc[final_df['ltv'] >= quantiles.iloc[0], 'segment'] = 'diamond'
                final_df.loc[final_df['ltv'].between(quantiles.iloc[1], quantiles.iloc[0]), 'segment'] = 'platinum'
                final_df.loc[final_df['ltv'].between(quantiles.iloc[2], quantiles.iloc[1]), 'segment'] = 'gold'
                final_df.loc[final_df['ltv'] <= quantiles.iloc[2], 'segment'] = 'silver'

 
                # ÏµúÍ∑ºÏóê ÎåìÍ∏Ä Î∞è Ïø†ÌÇ§Î•º ÏÇ¨Ïö©Ìïú ÎèÖÏûêÎì§Ïù∏ Í≤ΩÏö∞(lookie) ltvÏóê ÏÇ∞Ï∂úÎêú ÏòàÏÇ∞Ïóê Îî∞ÎùºÏÑú Ïñ¥Îñ§ ÎßàÏºÄÌåÖÏùÑ Ìï† Ïàò ÏûàÏùÑÏßÄ Ï†ÑÎûµÏùÑ ÏÑ∏ Ïö∏ Ïàò ÏûàÎã®ÎßêÏù¥Ï£†?

                final_df = pd.merge(final_df,user_timeinfo,on='user_id',how='inner')
                final_df['morning_ratio'] = round(final_df['morning']/(final_df['morning'] + final_df['day'] + final_df['night']) * 100)
                final_df['day_ratio'] = round(final_df['day']/(final_df['morning'] + final_df['day'] + final_df['night']) * 100)
                final_df['night_ratio'] = round(final_df['night']/(final_df['morning'] + final_df['day'] + final_df['night']) * 100)            


                # final_df['time'] = 0 
                # final_df.loc[(final_df['morning_ratio'] >= 30) | (final_df['day_ratio'] >= 30), 'time'] = 'morning/day'
                # final_df.loc[~(final_df['morning_ratio'] >= 30) | (final_df['day_ratio'] >= 30), 'time'] = 'morning/day'
                

                st.write(final_df)


            # FRML Ï∞®Ìä∏
            @st.cache_resource
            def hist (final_df):
                fig, axes = plt.subplots(1, 4, figsize=(16, 4))
                M_top20_per = np.percentile(final_df['monetary_value'], 80)
                axes[0].hist(final_df['monetary_value'], bins=20, alpha=0.5, color='blue', label='Monetary')
                axes[0].axvline(x=M_top20_per, color='red', linestyle='--', label=f'Top 20% : {int(M_top20_per)}')
                axes[0].set_title('Monetary Distribution')
                axes[0].legend()

                # frequency
                F_top20_per = np.percentile(final_df['frequency'], 80)
                axes[1].hist(final_df['frequency'], bins=20, alpha=0.5, color='blue', label='Frequency')
                axes[1].axvline(x=F_top20_per, color='red', linestyle='--', label = f'Top 20% : {int(F_top20_per)} ')
                axes[1].set_title('frequency Distribution')
                axes[1].legend()

                # Recency
                R_top20_per = np.percentile(final_df['recency'], 80)
                axes[2].hist(final_df['recency'], bins=20, alpha=0.5, color='blue', label='Recency')
                axes[2].axvline(x=R_top20_per, color='red', linestyle='--', label=f'Top 20% : {int(R_top20_per)}')
                axes[2].set_title('Recency Distribution')
                axes[2].legend()


                L_top20_per = np.percentile(final_df['ltv'], 80)
                # L_top40_per = np.percentile(final_df['ltv'], 60)
                axes[3].hist(final_df['ltv'], bins=20, alpha=0.5, color='blue', label='LTV')
                axes[3].axvline(x=L_top20_per, color='red', linestyle='--', label=f'Diamond(Top 20%) : {int(L_top20_per)}')
                # axes[3].axvline(x=L_top40_per, color='green', linestyle='--', label=f'Platinum : {int(L_top40_per)}')
                axes[3].set_title('LTV Distribution')
                axes[3].legend()


                plt.tight_layout()                
                st.pyplot(fig)

            st.write('''##### ÏÑ∏Í∑∏Î®ºÌä∏ ÎÇòÎàÑÍ∏∞ ''')
            st.caption(''' Í∑∏ÎûòÌîÑÏôÄ ÌååÎ†àÌÜ† Î≤ïÏπôÏùÑ Ïù¥Ïö©ÌïòÏó¨ segement ÏÇ∞Ï∂ú''')

            hist(final_df)

            R_top20_per = np.percentile(final_df['recency'], 80)            
            F_top20_per = np.percentile(final_df['frequency'], 80)
            M_top20_per = np.percentile(final_df['monetary_value'], 80)
            L_top20_per = np.percentile(final_df['ltv'], 80)

            st.write(f'''
                    * Recency ÏÉÅÏúÑ 20% : {int(R_top20_per)}
                    * Frequency ÏÉÅÏúÑ 20% : {int(F_top20_per)}
                    * Monetary ÏÉÅÏúÑ 20% : {int(M_top20_per)}
                    * LTV ÏÉÅÏúÑ 20% : {int(L_top20_per)}

                ''')






    # -------------------------------------------------------------- ÌîÑÎ°úÎ™®ÏÖòÏùÑ ÏßÑÌñâÌï† Ïö∞ÏÑ†ÏàúÏúÑ ÎèÖÏûê Ï†ïÌïòÍ∏∞ ------------------------------------------------------------- #            
    with st.container():
        st.subheader('üéÅ ÌîÑÎ°úÎ™®ÏÖòÏùÑ ÏßÑÌñâÌï† Ïö∞ÏÑ†ÏàúÏúÑ ÎèÖÏûê')
        # ÏÑ∏Í∑∏Î®ºÌä∏Î≥ÑÎ°ú 

        st.write(''' 
                > ##### ÌîÑÎ°úÎ™®ÏÖòÏùÑ ÏßÑÌñâÌï†ÏãúÏóê Î∞òÏùëÌï† ÌôïÎ•†Ïù¥ ÎÜíÏùÄ ÎèÖÏûêÎäî ÎàÑÍµ¨ÏùºÍπåÏöî? ÏÇ∞Ï∂úÎêú Í≥†Í∞ù ÏÉùÏï† Í∞ÄÏπò(LTV)ÏôÄ ÏÑúÎπÑÏä§Î•º Ï£ºÎ°ú Ïù¥Ïö©ÌïòÎäî ÏãúÍ∞ÑÎåÄÎ•º ÎÇòÎà†ÏÑú ÏïÑÎûòÏôÄ Í∞ôÏù¥ Ïö∞ÏÑ†ÏàúÏúÑÎ•º Ï†ïÌï¥Î≥¥ÏïòÏäµÎãàÎã§.  
                
                > 1. ltvÍ∞Ä ÎÜíÍ≥† Ïò§Ï†Ñ ÌòπÏùÄ ÎÇÆÏóê Ïù¥Ïö©ÌïòÎäî ÎèÖÏûê üëâüèª ÎØ∏ÎûòÍ∞ÄÏπòÍ∞Ä ÎÜíÏùÄ Í≥†Í∞ùÏù¥Î©¥ÏÑú ÏïÑÏπ®/ÎÇÆÏóê ÌÉÄÍ≤üÏúºÎ°ú ÎßåÎì§Ïñ¥ÏßÑ Ìï¥Îãπ ÌîÑÎ°úÎ™®ÏÖòÏóê Í∞ÄÏû• Ïûò Î∞òÏùëÌï† ÎèÖÏûê
                > 2. ltvÎäî ÎÇÆÏßÄÎßå Ïò§Ï†Ñ ÌòπÏùÄ ÎÇÆÏóêÎßå Ïù¥Ïö©ÌïòÎäî ÎèÖÏûê üëâüèª                  
                > 3. M ÏùÄ ÎÇÆÏßÄÎßå FÍ∞Ä ÎÜíÏùÄ ÎèÖÏûê üëâüèª ÌîÑÎ°úÎ™®ÏÖòÏóê Îî∞Îùº Ïø†ÌÇ§Î•º ÏÇ¨Ïö©Ìï† Ïàò ÏûàÎäî Ïû†Ïû¨ ÎèÖÏûê
                ''')

        

        dia_user = final_df.groupby(['segment']).agg(
            monetary_value = pd.NamedAgg(column='monetary_value',aggfunc='mean'),
            ltv = pd.NamedAgg(column='ltv',aggfunc='mean'),
            morning = pd.NamedAgg(column='morning',aggfunc='sum'),
            day = pd.NamedAgg(column='day',aggfunc='sum'),
            night = pd.NamedAgg(column='night',aggfunc='sum')

        )

        col1, col2 = st.columns([1.5,1.5])
        with col1:

            high_user = final_df[final_df['segment'].isin(['diamond','platinum'])]
            morning_day_user = high_user[(high_user['morning_ratio'] >= 30) | (high_user['day_ratio'] >= 30)]
            all_user = final_df[(final_df['morning_ratio'] >= 30) | (final_df['day_ratio'] >= 30)]



            f3 = final_df[final_df['frequency'] >= 3]
            morning_user_20 = f3[(f3['morning_ratio'] >= 30) | (f3['day_ratio'] >= 30)]

            st.write('''#### ÌÉÄÍ≤ü ÎèÖÏûê ''')
            st.caption(''' RFM Í∞íÏùÑ Ï°∞Ï†àÌïòÏó¨ Ï†ÅÏ†àÌïú ÌÉÄÍ≤üÏ∏µÏùÑ ÏÑ†Ï†ïÌï† Ïàò ÏûàÏäµÎãàÎã§.''') 
            # Ï†ÅÏñ¥ÎèÑ 3Î≤à Ïù¥ÏÉÅ(Frequency ÏÉÅÏúÑ 20%Ïóê Ìï¥ÎãπÌïòÎäî ÎèÖÏûê) ÎåìÍ∏ÄÏùÑ ÏûëÏÑ±Ìïú ÎèÖÏûêÎì§ÏùÑ Í∏∞Ï§ÄÏúºÎ°ú ÏÑ†Ï†ïÌñàÏäµÎãàÎã§.
            # st.write('''                     
            #          * 1Î≤à ÌÉÄÍ≤üÏóê Ìï¥ÎãπÌïòÎäî ÏòàÏãú ÎèÖÏûê 'ÏõπÌà∞(jetb****)'  ÎÜíÏùÄ LTV + Ïò§Ï†Ñ/ÎÇÆÏãúÍ∞ÑÎåÄ ÎèÖÏûê
            #          * 2Î≤à ÌÉÄÍ≤üÏóê Ìï¥ÎãπÌïòÎäî ÏòàÏãú ÎèÖÏûê 'Ï¶àÎßà81 (slay***)' 
            #          ''')
            # st.write(morning_user_20[morning_user_20['user_id'].str.contains('ÏõπÌà∞|Ï¶àÎßà')])
            # st.write(morning_user_20)            

            with st.container():
                # with st.form(key="asdf"):
                    c1, c2, c3= st.columns([2,2,2])
                    
                    with c1:
                        r_option = st.slider('Recency(ÏÉÅÏúÑ%)', 1, 100, (1, 100))
                        r_percentile = np.percentile(final_df['recency'], [100 - int(r_option[0]), 100 - int(r_option[1])])

                    with c2:

                        f_option = st.slider('frequency(ÏÉÅÏúÑ%)', 1, 100, (1, 100))
                        f_percentile = np.percentile(final_df['frequency'], [100 - int(f_option[0]), 100 - int(f_option[1])])

                    with c3:
                        # m_option = st.text_input('Monetary (ÏÉÅÏúÑ%)')
                        # if m_option:
                        #     m_percentile = np.percentile(final_df['monetary_value'], 100 - int(m_option))
                        m_option = st.slider('monetary_value(ÏÉÅÏúÑ%)', 1, 100, (1, 100))
                        m_percentile = np.percentile(final_df['monetary_value'], [100 - int(m_option[0]), 100 - int(m_option[1])])


                    # with c4:
                    #     submit_search = st.form_submit_button("ÌôïÏù∏")

                    filtered_df = final_df[(final_df['recency'].between(r_percentile[1], r_percentile[0]))
                                            & (final_df['frequency'].between(f_percentile[1], f_percentile[0]))
                                            & (final_df['monetary_value'].between(m_percentile[1], m_percentile[0]))
                                            ]


                    filtered_df['time'] = 'other'
                    filtered_df.loc[filtered_df['morning_ratio'] + filtered_df['day_ratio'] >= 50,'time'] = 'morning/day'

                    group = filtered_df.groupby(['segment','time']).agg(
                        segment_cnt = pd.NamedAgg(column='segment',aggfunc='count'),
                    ).reset_index()


                    c1,c2 = st.columns([1,1])
                    with c1:
                        st.write('''##### üìä chart by segment ''')
                        st.bar_chart(group, x="segment", y="segment_cnt", color="time",use_container_width=False,width=400,height=500)
                    with c2:
                        st.write('''##### dataframe ''')
                        st.write(filtered_df)
        
                        # pivot_df = filtered_df[['segment','frequency','recency','monetary_value','ltv','time']]

                # option_df = final_df[(final_df['recency'] >= int(r_option)) & (final_df['frequency'] >= int(f_option)) & (final_df['monetary_value'] >= int(m_option))]



            # with elements("target user"):
            #     layout = [
            #         dashboard.Item("item_1", 0, 0, 6, 2),
            #     ]

            #     with dashboard.Grid(layout):               
            #         mui.Box(
            #             nivo.Pie(
            #                 data= [],
            #                 margin={"top": 50, "right": 20, "bottom": 50, "left": 80 },
            #                 sortByValue=True,
            #                 innerRadius={0.5},
            #                 padAngle={2},
            #                 colors= { 'scheme': 'pastel1' }, # pastel1
            #                 borderWidth={1},
            #                 borderColor={
            #                     "from": 'color',
            #                     "modifiers": [
            #                         [
            #                             'opacity',
            #                             0.2
            #                         ]
            #                     ]
            #                 },
            #                 enableArcLinkLabels=True,
            #                 # arcLabel="id",
            #                 arcLabelsRadiusOffset={0.5},
            #                 arcLinkLabelsSkipAngle={3},
            #                 arcLinkLabelsThickness={1},
            #                 arcLabelsTextColor="black",
            #                 arcLabelsSkipAngle={10},
            #             legends=[
            #                     {
            #                     'anchor': 'top-left',
            #                     'direction': 'column',
            #                     'justify': False,
            #                     'translateX': -70,
            #                     # 'translateY': -200,
            #                     'itemsSpacing': 0,
            #                     'itemDirection': 'left-to-right',
            #                     'itemWidth': 80,
            #                     'itemHeight': 15,
            #                     'itemOpacity': 0.75,
            #                     'symbolSize': 12,
            #                     'symbolShape': 'circle',
            #                     'symbolBorderColor': 'rgba(0, 0, 0, .5)',
            #                     'effects': [
            #                             {
            #                             'on': 'hover',
            #                             'style': {
            #                                 'itemBackground': 'rgba(0, 0, 0, .03)',
            #                                 'itemOpacity': 1
            #                                 }
            #                             }
            #                         ]
            #                     }
            #                 ],                                                     
            #                 theme={
            #                     # "background": "#141414",
            #                     "textColor": "black",
            #                     "tooltip": {
            #                         "container": {
            #                             "background": "#3a3c4a",
            #                             "color": "black",
            #                         }
            #                     }
            #                 }
            #             )
            #             ,key="item_1" )





        with col2:
            # ÏõπÌà∞ (jetb****) # LTV ÎèÑ ÎÜíÍ≥† Ïò§Ï†Ñ/ÎÇÆ Ïú†Ï†Ä
            # Ï¶àÎßà81 (slay****)  # LTVÎäî ÎÇÆÏßÄÎßå Ïò§Ï†Ñ/ÎÇÆÏóê Ï£ºÎ°ú Ïù¥Ïö©ÌïòÎäî Ïú†Ï†Ä 
            # morning_user_log = comment_data[comment_data['hour'].between(6, 18)]
            st.write('''#### ÏòàÏÇ∞ ''')
            st.write(f''' 
                     Ï†ÑÏ≤¥ Ïú†ÎãàÌÅ¨Ìïú ÎèÖÏûê : {len(final_df)}Î™Ö  
                     Ïò§Ï†Ñ/ÎÇÆÏóê Í∞êÏÉÅ ÎπÑÏú®Ïù¥ 30% Ïù¥ÏÉÅÏù∏ ÎèÖÏûê : {len(all_user)}Î™Ö   
                     Ïò§Ï†Ñ/ÎÇÆÏóê Í∞êÏÉÅ ÎπÑÏú®Ïù¥ 30% Ïù¥ÏÉÅÏù¥Í≥† LTVÍ∞Ä Platinum Ïù¥ÏÉÅÏù∏ ÎèÖÏûê: {len(morning_day_user)}
                    
                    ''')
            st.write('''
                    ÌîÑÎ°úÎ™®ÏÖò ÏßÑÌñâ ÏòàÏÇ∞Ïù¥ 1Î™ÖÎãπ 1000ÏõêÏù¥ÎùºÍ≥† ÌñàÏùÑ Îïå, 


                 ''')


 


    # with st.container():




        # import plotly.graph_objects as go

        # bronze_group = final_df[final_df['segment'] == 'bronze']
        # silver_group = final_df[final_df['segment'] == 'silver']
        # gold_group = final_df[final_df['segment'] == 'gold']        
        # platinum_group = final_df[final_df['segment'] == 'platinum']
        # diamond_group = final_df[final_df['segment'] == 'diamond']

        # # Plotly subplot Í∑∏ÎûòÌîÑ ÏÉùÏÑ±
        # fig = go.Figure()
        # # Monetary subplot
        # fig.add_trace(go.Histogram(x=diamond_group['monetary_value'], name='diamond'))
        # # Frequency subplot
        # fig.add_trace(go.Histogram(x=platinum_group['monetary_value'], name='platinum'))
        # # Recency subplot
        # fig.add_trace(go.Histogram(x=gold_group['monetary_value'], name='gold'))

        # # Í∑∏ÎûòÌîÑ Î†àÏù¥ÏïÑÏõÉ ÏÑ§Ï†ï
        # fig.update_layout(title='Distribution of Monetary',
        #                 barmode='overlay')

        # # StreamlitÏóê Í∑∏ÎûòÌîÑ ÌëúÏãú
        # st.plotly_chart(fig)

        # st.markdown(''' 
        #     #### ‚ë° Î™©ÌëúÎ•º Î∂ÄÏó¨ÌïòÏó¨ ÎèÖÏûêÎì§Ïùò Ï∞∏Ïó¨ÎèÑ Ïò¨Î¶¨Í∏∞  
        #     ÏõπÌà∞ ÏàòÏùµÍµ¨Ï°∞Ïóê Îî∞Î•¥Î©¥ Ï°∞ÌöåÏàò Í∑∏Î¶¨Í≥† ÎèÖÏûêÎì§Ïùò Ï∞∏Ïó¨ÎèÑÍ∞Ä ÍµâÏû•Ìûà Ï§ëÏöîÌïòÎã§Îäî Í≤ÉÏùÑ Ïïå Ïàò ÏûàÏäµÎãàÎã§. 
        #     ÏÇ∞Ï∂úÎêú ltv Î°ú ÎÇòÎà†ÏßÑ ÏÑ∏Í∑∏Î®ºÌä∏Ïóê Îî∞Îùº Ïó¥ÌòàÎèÖÏûê, ÏùºÎ∞òÎèÖÏûê Îû≠ÌÅ¨Î•º ÎààÏóê Î≥¥Ïù¥Í≤å Î∂ÄÏó¨ÌïòÎ©¥ Ïñ¥Îñ®ÍπåÏöî? Ïó¥ÌòàÎèÖÏûêÎ•º Îã¨Í∏∞ ÏúÑÌïú ÏùºÏ¢ÖÏùò Î™©ÌëúÎ•º ÎßåÎì§Ïñ¥ Ï§åÏúºÎ°úÏç® Í∏∞Ï°¥Ïùò Í∏∞Ïó¨ÎèÑÍ∞Ä ÎÜíÏùÄ ÎèÖÏûê ÎøêÎßå ÏïÑÎãàÎùº Îã§Î•∏ ÎèÖÏûêÎì§Ïùò Ï∞∏Ïó¨ÎèÑÎ•º ÎÜíÌûàÎäîÍ≤É ÏûÖÎãàÎã§!
        #     Í≤åÏûÑÏ≤òÎüº LTV ÏàòÏπòÍ∞Ä ÏùºÏ¢ÖÏóê Í≤ΩÌóòÏπòÍ∞Ä ÎêòÍ≥†, Ïù¥Îäî ÎèÖÏûêÏùò Ï∞∏Ïó¨ÎèÑ(ÎåìÍ∏Ä, Ï¢ãÏïÑÏöî, Î≤†Ïä§Ìä∏ ÎåìÍ∏Ä ,Ïø†ÌÇ§ ÏÇ¨Ïö© Îì±)Î•º ÌÜµÌï¥ Îì±Í∏âÏù¥ Ïò¨Îùº Í∞êÏúºÎ°úÏÑú ÏÑ±Ï∑®Í∞êÏùÑ ÎäêÎÅºÍ≤å ÌïúÎã§Î©¥ ÎèÖÏûêÎì§Ïùò Ï∞∏Ïó¨ÎèÑÍ∞Ä Îçî ÎÜíÏïÑÏßà Ïàò ÏûàÏäµÎãàÎã§.
            
        #     ''')


    st.divider()




    # -------------------------------------------------------------- Ïø†ÌÇ§Í∞Ä Í∞ÄÏû• ÎßéÏù¥ ÏÇ¨Ïö©Îêú ÏóêÌîºÏÜåÎìú Î∂ÑÏÑù ------------------------------------------------------------- #

    with st.container():            
            st.subheader('üç™ Episode By Cookie')
            st.caption(''' Ïø†ÌÇ§ÏÇ¨Ïö©ÎüâÏù¥ ÎÜíÏïòÎçò ÏóêÌîºÏÜåÎìúÏùò ÌäπÏßïÏùÄ Î¨¥ÏóáÏùºÍπåÏöî? ÏóêÌîºÏÜåÎìúÎ≥Ñ(x:ÏóÖÎ°úÎìúÎêú ÎÇ†Ïßú) Ïø†ÌÇ§ ÏÇ¨Ïö©ÎüâÏùÑ ÏãúÍ∞ÅÌôîÌïòÏó¨ Í∞ÄÏû• Í∞ÄÏπòÍ∞Ä ÎÜíÏïòÎçò ÏóêÌîºÏÜåÎìúÎ•º Ï∞æÏïÑÎ≥¥Í≥† ÎèÖÏûêÎì§Ïùò ÎãàÏ¶àÎ•º ÌååÏïÖÌï¥Î≥¥ÏïòÏäµÎãàÎã§.''')    
         
            cookie_by_ep = ltv_df.groupby(['chapter','episode','upload_at']).agg(
                total_cookie = pd.NamedAgg(column='cookie', aggfunc='sum')            
            ).reset_index().sort_values(by=['upload_at'])


            # cookie_by_ep['upload_at'] = pd.to_datetime(cookie_by_ep['upload_at']).dt.strftime('%Y-%m-%d')
            # cookie_by_ep['month'] = pd.to_datetime(cookie_by_ep['upload_at']).dt.strftime('%Y-%m')

            mean_cookie = round(cookie_by_ep['total_cookie'].mean())

           # Îç∞Ïù¥ÌÑ∞ Î≥ÄÌôò
            nivo_data_cookie = []
            for index, row in cookie_by_ep.iterrows():
                nivo_data_cookie.append({'x': row['upload_at'], 'y': row['total_cookie']})

            nivo_data_cookie = [{
                "id": "cookie",
                "data": nivo_data_cookie
            }]
            

            top_cookie  = cookie_by_ep.sort_values(by=['total_cookie'],ascending=False)
            recent_data = main_data[main_data['down_at'] =='2024-03-06'][['episode','like_count','comment_count','score']] # 240306 Í∏∞Ï§ÄÏùò ÏóêÌîºÏÜåÎìú Ï†ïÎ≥¥ Í≤∞Ìï©
            top_cookie  = pd.merge(top_cookie,recent_data,on='episode',how='inner') 



            col1,col2 = st.columns([3,3])
            with col1:
                st.markdown('''##### üìà Cookie Chart''')

                with elements("cookie chart"):
                            layout = [
                                dashboard.Item("item_1", 0, 0, 6, 2),
                                dashboard.Item("item_2", 0, 2, 2, 1.8),
                                dashboard.Item("item_3", 2, 2, 2, 1.8),
                                dashboard.Item("item_4", 4, 2, 2, 1.8),

                            ]

                            with dashboard.Grid(layout):                                                            
                                mui.Box(                                        
                                    nivo.Line(
                                        data= nivo_data_cookie,
                                        margin={'top': 30, 'right': 30, 'bottom': 30, 'left': 60},
                                        # xScale={'type': 'point',
                                        #         },

                                        curve="monotoneX",
                                        axisTop=None,
                                        axisRight=None,
                                        axisBottom={
                                            'format': '%y-%m-%d',  # '%Y-%m-%d'
                                            'legendOffset': -12,
                                            'tickValues': 'every 30 days'
                                        },
                                        xFormat="time:%Y-%m-%d",
                                        xScale={
                                            'format': '%Y-%m-%d',
                                            'precision': 'day',
                                            'type': 'time',
                                            # 'useUTC': False
                                        },
                                        colors= {'scheme': 'accent'},

                                        enableGridX = False,
                                        enableGridY = False,
                                        enableArea = True,
                                        areaOpacity = 0.2,
                                        # enablePointLabel=True,
                                        # pointLabel='y',
                                        lineWidth=2,
                                        pointSize=3,
                                        pointColor='white',
                                        pointBorderWidth=0.5,
                                        pointBorderColor={'from': 'serieColor'},
                                        pointLabelYOffset=-12,
                                        useMesh=True,
                                        legends=[
                                                    {
                                                    'anchor': 'top-left',
                                                    'direction': 'column',
                                                    'justify': False,
                                                    # 'translateX': -30,
                                                    # 'translateY': -200,
                                                    'itemsSpacing': 0,
                                                    'itemDirection': 'left-to-right',
                                                    'itemWidth': 80,
                                                    'itemHeight': 15,
                                                    'itemOpacity': 0.75,
                                                    'symbolSize': 12,
                                                    'symbolShape': 'circle',
                                                    'symbolBorderColor': 'rgba(0, 0, 0, .5)',
                                                    'effects': [
                                                            {
                                                            'on': 'hover',
                                                            'style': {
                                                                'itemBackground': 'rgba(0, 0, 0, .03)',
                                                                'itemOpacity': 1
                                                                }
                                                            }
                                                        ]
                                                    }
                                                ],                            
                                        theme={
                                                # "background-color": "rgba(158, 60, 74, 0.2)",
                                                "textColor": "black",
                                                "tooltip": {
                                                    "container": {
                                                        "background": "#3a3c4a",
                                                        "color": "white",
                                                    }
                                                }
                                            },
                                        markers=[{                                                
                                            'axis': 'y',
                                            'legend': 'mean',
                                            'lineStyle': {
                                                'stroke': '#b0413e',
                                                'strokeWidth': 1
                                            },
                                            'value': mean_cookie                                              
                                        }] ,                                             
                                        animate= False)
                                        ,key="item_1",sx={"borderRadius":"15px", "borderRadius":"15px","background-color":"#F0F2F6"}) 

                                mui.Card( # Ïç∏ÎÑ§Ïùº,Ï¢ãÏïÑÏöî,ÎåìÍ∏Ä,ÎßÅÌÅ¨           
                                    children=[      
                                        mui.Typography(
                                            f"ü•á {top_cookie['upload_at'].iloc[0]}",
                                            color="text.secondary",
                                            sx={"font-size": "14px",
                                                # "fontWeight":"bold",
                                                "text-align":"left",
                                                "padding-left":"12px",
                                                "padding-top" : "2px"
                                                },                                            
                                        ),
                                        mui.CardMedia( # Ïç∏ÎÑ§Ïùº Ïù¥ÎØ∏ÏßÄ
                                            sx={ "height": 150,
                                                "ovjectFit":"cover",
                                                "backgroundImage": f"linear-gradient(rgba(0, 0, 0, 0), rgba(0,0,0,0.5)), url(https://image-comic.pstatic.net/webtoon/811721/67/thumbnail_202x120_dd2e1d7e-c605-43ba-b9d5-5df6e80b95b4.jpg)",
                                                # "borderRadius": '5%', 
                                                "backgroundPosition": "top 80%",
                                                # "border": "1.5px solid white",  # Ìù∞ÏÉâ Í≤ΩÍ≥ÑÏÑ† Ï∂îÍ∞Ä
                                                },                                
                                            title = 'Ïç∏ÎÑ§Ïùº'
                                                ),
                
                                        mui.CardContent(  # ÌÉÄÏù¥ÌãÄ 
                                            sx={"padding-top": "10px",
                                                "padding-bottom":"10px",
                                                "max-height": "100%",
                                                "overflow": "hidden"},

                                                children=[
                                                    mui.Typography( # title
                                                        f"{top_cookie['episode'].iloc[0]}",
                                                        component="div",
                                                        sx={"font-size":"16px",
                                                            "fontWeight":"bold",
                                                            "height":"45px",
                                                            "max-height": "100%",
                                                            # "overflow": "hidden",
                                                            }                            
                                                    )],

                                            ),
                                                                            
                                        mui.CardContent( # ÎåìÍ∏Ä Ï¢ãÏïÑÏöî ÎßÅÌÅ¨
                                            sx={"display": "flex",
                                                "padding-top": "0",
                                                "padding-bottom":"0",
                                                "gap": "60px",
                                                "align-items": "center", # "position": "fixed"
                                                },
                                                
                                            children=[

                                                mui.Typography(
                                                        f"‚ù§Ô∏è {top_cookie['like_count'].iloc[0]} ÎåìÍ∏Ä {top_cookie['comment_count'].iloc[0]} ",
                                                        variant="body2",
                                                        sx={"font-size": "12px"},                                            
                                                    ),

                                                mui.Link(
                                                    "üìñWebtoon",
                                                    href=f"https://comic.naver.com/webtoon/detail?titleId=811721&no={top_cookie['chapter'].iloc[0]}",
                                                    target="_blank",
                                                    sx={"font-size": "12px",
                                                        "font-weight": "bold",
                                                        }
                                                ),
                                            ]
                                        ),
                                        
                                        ] 
                                        ,key="item_2",sx={"background-color" : "#F0F2F6", "background-size" : "cover","borderRadius": '20px'})

                                mui.Card( # Ïç∏ÎÑ§Ïùº,Ï¢ãÏïÑÏöî,ÎåìÍ∏Ä,ÎßÅÌÅ¨           
                                    children=[      
                                        mui.Typography(
                                            f"ü•à {top_cookie['upload_at'].iloc[1]}",
                                            color="text.secondary",
                                            sx={"font-size": "14px",
                                                # "fontWeight":"bold",
                                                "text-align":"left",
                                                "padding-left":"12px",
                                                "padding-top" : "2px"
                                                },                                            
                                        ),
                                        mui.CardMedia( # Ïç∏ÎÑ§Ïùº Ïù¥ÎØ∏ÏßÄ
                                            sx={ "height": 150,
                                                "ovjectFit":"cover",
                                                "backgroundImage": f"linear-gradient(rgba(0, 0, 0, 0), rgba(0,0,0,0.5)), url(https://image-comic.pstatic.net/webtoon/811721/78/thumbnail_202x120_605ae5f8-d2ff-400e-b175-d61e3b68d737.jpg)",
                                                "backgroundPosition": "top 80%",
                                                # "border": "1.5px solid white",  # Ìù∞ÏÉâ Í≤ΩÍ≥ÑÏÑ† Ï∂îÍ∞Ä
                                                },                                
                                            title = 'Ïç∏ÎÑ§Ïùº'
                                                ),
                
                                        mui.CardContent(  # ÌÉÄÏù¥ÌãÄ 
                                            sx={"padding-top": "10px",
                                                "padding-bottom":"10px",
                                                "max-height": "100%",
                                                "overflow": "hidden"},

                                                children=[
                                                    mui.Typography( # title
                                                        f"{top_cookie['episode'].iloc[1]}",
                                                        component="div",
                                                        sx={"font-size":"16px",
                                                            "fontWeight":"bold",
                                                            "height":"45px",
                                                            "max-height": "100%",
                                                            # "overflow": "hidden",
                                                            }                            
                                                    )],

                                            ),
                                                                            
                                        mui.CardContent( # ÎåìÍ∏Ä Ï¢ãÏïÑÏöî ÎßÅÌÅ¨
                                            sx={"display": "flex",
                                                "padding-top": "0",
                                                "padding-bottom":"0",
                                                "gap": "60px",
                                                "align-items": "center", # "position": "fixed"
                                                },
                                                
                                            children=[

                                                mui.Typography(
                                                        f"‚ù§Ô∏è {top_cookie['like_count'].iloc[1]} ÎåìÍ∏Ä {top_cookie['comment_count'].iloc[1]} ",
                                                        variant="body2",
                                                        sx={"font-size": "12px"},                                            
                                                    ),

                                                mui.Link(
                                                    "üìñWebtoon",
                                                    href=f"https://comic.naver.com/webtoon/detail?titleId=811721&no={top_cookie['chapter'].iloc[1]}",
                                                    target="_blank",
                                                    sx={"font-size": "12px",
                                                        "font-weight": "bold",
                                                        }
                                                ),
                                            ]
                                        ),
                                        
                                        ] 
                                        ,key="item_3",sx={"background-color" : "#F0F2F6", "background-size" : "cover","borderRadius": '20px'})

                                mui.Card( # Ïç∏ÎÑ§Ïùº,Ï¢ãÏïÑÏöî,ÎåìÍ∏Ä,ÎßÅÌÅ¨           
                                    children=[      
                                        mui.Typography(
                                            f"ü•â {top_cookie['upload_at'].iloc[2]}",
                                            color="text.secondary",
                                            sx={"font-size": "14px",
                                                "text-align":"left",
                                                "padding-left":"12px",
                                                "padding-top" : "2px"
                                                },                                            
                                        ),
                                        mui.CardMedia( # Ïç∏ÎÑ§Ïùº Ïù¥ÎØ∏ÏßÄ
                                            sx={ "height": 150,
                                                "ovjectFit":"cover",
                                                "backgroundImage": f"linear-gradient(rgba(0, 0, 0, 0), rgba(0,0,0,0.5)), url(https://image-comic.pstatic.net/webtoon/811721/76/thumbnail_202x120_8cb1fe5a-8ab4-422b-a398-8a43f5deb29e.jpg)",
                                                # "borderRadius": '5%', 
                                                "backgroundPosition": "top 80%",
                                                # "border": "1.5px solid white",  # Ìù∞ÏÉâ Í≤ΩÍ≥ÑÏÑ† Ï∂îÍ∞Ä
                                                },                                
                                            title = 'Ïç∏ÎÑ§Ïùº'
                                                ),
                
                                        mui.CardContent(  # ÌÉÄÏù¥ÌãÄ 
                                            sx={"padding-top": "10px",
                                                "padding-bottom":"10px",
                                                "max-height": "100%",
                                                "overflow": "hidden"},

                                                children=[
                                                    mui.Typography( # title
                                                        f"{top_cookie['episode'].iloc[2]}",
                                                        component="div",
                                                        sx={"font-size":"16px",
                                                            "fontWeight":"bold",
                                                            "height":"45px",
                                                            "max-height": "100%",
                                                            # "overflow": "hidden",
                                                            }                            
                                                    )],

                                            ),
                                                                            
                                        mui.CardContent( # ÎåìÍ∏Ä Ï¢ãÏïÑÏöî ÎßÅÌÅ¨
                                            sx={"display": "flex",
                                                "padding-top": "0",
                                                "padding-bottom":"0",
                                                "gap": "60px",
                                                "align-items": "center", # "position": "fixed"
                                                },
                                                
                                            children=[

                                                mui.Typography(
                                                        f"‚ù§Ô∏è {top_cookie['like_count'].iloc[2]} ÎåìÍ∏Ä {top_cookie['comment_count'].iloc[2]} ",
                                                        variant="body2",
                                                        sx={"font-size": "12px"},                                            
                                                    ),

                                                mui.Link(
                                                    "üìñWebtoon",
                                                    href=f"https://comic.naver.com/webtoon/detail?titleId=811721&no={top_cookie['chapter'].iloc[2]}",
                                                    target="_blank",
                                                    sx={"font-size": "12px",
                                                        "font-weight": "bold",
                                                        }
                                                ),
                                            ]
                                        ),
                                        
                                        ] 
                                        ,key="item_4",sx={"background-color" : "#F0F2F6", "background-size" : "cover","borderRadius": '20px'})




            with col2:
                st.markdown('''### üß™ Ïã§Ìóò Í∞ÄÏÑ§  ''')
                st.write(''' 
                    > " **ÏãúÎ¶¨Ï¶à ÌòïÌÉúÏùò ÏóêÌîºÏÜåÎìú**ÏùºÏàòÎ°ù Ïø†ÌÇ§ ÏÇ¨Ïö©ÎüâÏù¥ ÎÜíÏùÑÍ≤É Ïù¥Îã§. "  
                    ÌïòÎ£®Î∂ÑÎüâÏúºÎ°ú ÎÅùÎÇòÎäî 'Îã®Ìé∏ Ïä§ÌÜ†Î¶¨'ÏôÄ Î∞òÎåÄÎ°ú Í≥ÑÏÜçÌï¥ÏÑú Ïù¥Ïñ¥ÏßÄÎäî 'ÏãúÎ¶¨Ï¶à ÌòïÌÉúÏùò ÏóêÌîºÏÜåÎìú'Ïùò Í≤ΩÏö∞ ÎèÖÏûêÎì§Ïùò ÏûÖÏû•ÏóêÏÑú **Îí∑ ÎÇ¥Ïö©Ïóê ÎåÄÌïú Í∂ÅÍ∏àÏ¶ù**Ïù¥ Ïú†Î∞úÎêòÍ≥† Ïù¥Ïóê Îî∞Îùº Ïø†ÌÇ§Î•º ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏùÑÍπå? ÏÉùÍ∞ÅÏù¥ Îì§ÏóàÏäµÎãàÎã§.ü§î 
                    ''')
                st.caption('''
                    * Ï¥àÍ∏∞Ïóê ÎØ∏Î¶¨Î≥¥Í∏∞Ìï† ÏõπÌà∞Ïù¥ ÏóÜÎã§Îäî Ï†êÏùÑ Í≥†Î†§ + cookie Í∞Ä 0 Ïù∏ ÏóêÌîºÏÜåÎìúÎäî Ï†úÏô∏ÌïòÏòÄÏäµÎãàÎã§.
                    * 2Í∞ú Ïù¥ÏÉÅÏùò ÏóêÌîºÏÜåÎìú(A) Îã®Ìé∏ ÏóêÌîºÏÜåÎìú(B) ÎëêÍ∞úÏùò ÏßëÎã®ÏúºÎ°ú ÎÇòÎàÑÍ≥† ÎèÖÎ¶ΩÌëúÎ≥∏T Í≤ÄÏ†ïÏùÑ ÏßÑÌñâÌñàÏäµÎãàÎã§.
                         ''')



                # Ï†úÎ™© ÌòïÏãùÏóê ' : ' Î•º Í∏∞Ï§ÄÏúºÎ°ú Î∂ÑÎ¶¨
                # \s* Í≥µÎ∞± \(\d+\) Í¥ÑÌò∏ÏïàÏùò Ïà´Ïûê Ï†úÍ±∞
                cookie_by_ep['title'] = cookie_by_ep['episode'].apply(lambda x: re.sub(r'\s*\(\d+\)$', '', x.split(':')[1]).strip()) 
                cookie_by_ep.loc[cookie_by_ep['chapter'] == '67', 'title'] = cookie_by_ep.loc[cookie_by_ep['chapter'] == '67', 'title'].str[:4]

                cookie_by_ep = cookie_by_ep[cookie_by_ep['total_cookie'] > 0]
                group = cookie_by_ep.groupby(['title']).agg(
                    cookie_mean = pd.NamedAgg(column='total_cookie',aggfunc='mean'),
                    series_cnt = pd.NamedAgg(column='episode',aggfunc='count'),
                ).reset_index()

                group_1 = group[group['series_cnt'] > 1]['cookie_mean']
                group_2 = group[group['series_cnt'] != 1 ]['cookie_mean']

      
                c1,c2 = st.columns([1,1])
                with c1:            
                    st.markdown('''##### ‚ë† Ï†ïÍ∑úÏÑ± Î∞è Îì±Î∂ÑÏÇ∞ÏÑ± ÌôïÏù∏''')

                    # Ï†ïÍ∑úÏÑ±Í≤ÄÏ†ï
                    fig = plt.figure(figsize=(8, 6))
                    sns.histplot(group['cookie_mean'], kde=True, color='blue', bins=10)
                    plt.title('Density Plot of cookie')
                    plt.xlabel('cookie_mean')
                    plt.ylabel('Density')
                    st.pyplot(fig)
 
 
                     # Îì±Î∂ÑÏÇ∞ÏÑ± Í≤ÄÏ†ï
                    _, p_levene = levene(group_1, group_2)
                    st.write(f'''
                              * Ï†ïÍ∑úÎ∂ÑÌè¨Ïùò ÌòïÌÉúÎ•º ÎùÑÍ≥† ÏûàÏäµÎãàÎã§.
                              * Levene's p_value : {p_levene}ÏúºÎ°ú Îì±Î∂ÑÏÇ∞ÏÑ±ÏùÑ ÎßåÏ°±Ìï©ÎãàÎã§.  ''') 


                with c2:                    
                    st.markdown('''##### ‚ë° ÎèÖÎ¶Ω ÌëúÎ≥∏ t-Í≤ÄÏ†ï ''')
                    # ÎèÖÎ¶ΩÌëúÎ≥∏ t-Í≤ÄÏ†ï
                    t_statistic, p_value = ttest_ind(group_1, group_2)

                    # Í≤∞Í≥º Ï∂úÎ†•
                    st.write(f'''
                             > Í≤ÄÏ†ïÍ≤∞Í≥º ÏïÑÏâΩÍ≤åÎèÑ ÏãúÎ¶¨Ï¶à ÌòïÌÉúÏùò ÏóêÌîºÏÜåÎìú ÎùºÍ≥† Ïø†ÌÇ§ ÏÇ¨Ïö©ÎüâÏù¥ ÎÜíÎã§ÎùºÍ≥† Î≥º ÏàòÎäî ÏóÜÏóàÏäµÎãàÎã§.
                             * Îã®ÏàúÌûà ÏãúÎ¶¨Ï¶àÏùò Í∏∏Ïù¥ Î≥¥Îã§ Ìï¥Îãπ ÏóêÌîºÏÜåÎìúÏùò **'Ïû¨ÎØ∏ÎèÑ', 'Ïû•Î•¥Î∞òÏ†Ñ', 'ÏÑúÎπÑÏä§Ïã†'** Í∞ôÏùÄ ÏöîÏÜåÎì§Ïù¥ Ïø†ÌÇ§ ÏÇ¨Ïö©ÎüâÏóê Îî∞Îùº Ï∞®Ïù¥Í∞Ä ÏûàÏßÄ ÏïäÏùÑÍπå ÏÉùÍ∞ÅÏù¥ Îì§ÏóàÏäµÎãàÎã§. Ïù¥Ïóê ÎåÄÌïú Ï∂îÍ∞ÄÏ†ÅÏù∏ Î∂ÑÏÑùÏùÑ ÏßÑÌñâÌïòÎ©¥ Ï¢ãÏùÑÍ≤É Í∞ôÏäµÎãàÎã§.
                             * ÎòêÌïú Ìï¥Îãπ ÏõπÌà∞Ïùò Í≤ΩÏö∞ Íæ∏Ï§ÄÌûà Ïø†ÌÇ§ÏÇ¨Ïö©ÎüâÏù¥ Ï¶ùÍ∞ÄÌïòÍ≥† ÏûàÎäî Ï∂îÏÑ∏ÏûÖÎãàÎã§. (ÏÉÅÎåÄÏ†ÅÏúºÎ°ú Ïù∏Í∏∞Í∞Ä ÏóÜÏóàÎçò) Ï¥àÍ∏∞Ïóê ÎÇòÏò® ÏóêÌîºÏÜåÎìúÏôÄ ÌòÑÏû¨Ïùò ÏóêÌîºÏÜåÎìúÎ•º Í∞ôÏù¥ ÎπÑÍµêÌïòÍ∏∞ÏóêÎäî ÌïúÍ≥ÑÍ∞Ä ÏûàÎã§Í≥† ÏÉùÍ∞ÅÏù¥ Îì§ÏóàÏäµÎãàÎã§.                             
                             * Îç∞Ïù¥ÌÑ∞Ïùò ÌïúÍ≥Ñ ÎòêÌïú ÏòÅÌñ•Ïù¥ ÏûàÏäµÎãàÎã§.
                             * T-statistic : {t_statistic}  
                             P-value : {p_value}                               

                             
                                                         ''')
 

            # st.markdown('''
            #             ##### ‚ë† Ïû•Î•¥ Î∞òÏ†Ñ
            #             Í∞ÄÏû• ÎÜíÏùÄ cookie Ï†êÏàòÎ•º Îã¨ÏÑ±Ìïú Îß§ÎÑàÎ¶¨Ï¶ò ÏóêÌîºÏÜåÎìúÏùò Í≤ΩÏö∞ Ìï¥Îãπ ÏõπÌà∞Ïùò '1Î∂Ä ÎßàÎ¨¥Î¶¨'ÎùºÎäî Ïù¥Î≤§Ìä∏Ïùò ÏòÅÌñ•ÎèÑ ÏûàÏßÄÎßå 
            #             Í∑∏ ÎèôÏïà Îã®ÏàúÌûà Í∞ÄÎ≤ºÏö¥ Í∞úÍ∑∏Î¨ºÎ°ú Î≥¥ÏïÑÏôîÎçò ÏûëÌíàÏïàÏóêÏÑú 'ÏßÑÏßÄÌï®' 'Í∞êÎèô' Ïù¥ÎùºÎäî Ïû•Î•¥Ïùò Î∞òÏ†ÑÏùÑ Ï∂îÍ∞ÄÌïòÎ©¥ÏÑú ÎèÖÏûêÎì§ÏóêÍ≤å ÌÅ∞ Ïù∏ÏÉÅÏùÑ Ï§ÄÍ≤ÉÏùÑ Ïïå Ïàò ÏûàÏäµÎãàÎã§.
                        
            #             ##### ‚ë° ÏÑúÎπÑÏä§Ïã†
            #             Î¨¥ÏßÅÎ∞±Ïàò Í≥ÑÎ∞±Ïàú ÏõπÌà∞Ïùò Í≤ΩÏö∞ ÏûëÌôî, Ï∫êÎ¶≠ÌÑ∞Í∞Ä ÏòàÏÅòÎã§Îäî ÌÅ∞ Îß§Î†• Ìè¨Ïù∏Ìä∏Í∞Ä ÏûàÏäµÎãàÎã§. ÌäπÌûà, 78Ìôî: Ï¥àÎåÄ(1)Ïùò ÏóêÌîºÏÜåÎìúÏùò Í≤ΩÏö∞ Ïù¥Î•º Í∑πÎåÄÌôî ÌïòÎäî ÏÑúÎπÑÏä§ Ïû•Î©¥Ïù¥ Ï∂îÍ∞Ä ÎêòÎ©¥ÏÑú ÎèÖÏûêÎì§Ïùò ÌÅ∞ Î∞òÏùëÏùÑ Ïù¥ÎÅàÍ≤ÉÏúºÎ°ú Î≥¥ÏûÖÎãàÎã§.
                            
            #             ##### ‚ë¢ Í∑∏ÎÉ• ÏõÉÍ∏∞Îã§.
            #             Ïù¥ Ïô∏Ïóê 'Í∞úÍ∑∏' Ïû•Î•¥ ÎãµÍ≤å ÎèÖÏûêÎì§Ïùò ÏõÉÏùå ÏΩîÎìúÎ•º Ïûò ÏÇ¥Î¶¨Îäî ÏóêÌîºÏÜåÎìúÏùò Í≤ΩÏö∞ ÎèÖÏûêÎì§Ïùò Î∞òÏùëÏù¥ Ï¢ãÏùÄÍ≤ÉÏùÑ Î≥º Ïàò ÏûàÏäµÎãàÎã§.

            #             ''')
